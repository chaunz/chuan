(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-5f1597d3","chunk-2d0c8bf7","chunk-74d095fd","chunk-2d0aeb86","chunk-2d22d403","chunk-2d0d32a5","chunk-2d217de2","chunk-2d224ea3","chunk-2d0e546a","chunk-2d21b8d7","chunk-2d213a21","chunk-2d2178e9","chunk-2d237aa4","chunk-2d0df462","chunk-2d23055c","chunk-2d0c89ab","chunk-2d2102b8","chunk-2d0c8fa8","chunk-2d217369","chunk-2d2106b9","chunk-2d2089ff","chunk-2d21aefa","chunk-2d208dec","chunk-2d0e5b70","chunk-2d0af43d","chunk-2d0ba0fa","chunk-2d2297c9"],{"0aed":function(l,v,i){l.exports=i.p+"img/1675132607672.e98ff376.png"},"0e1c":function(l,v,i){l.exports=i.p+"img/1676967325481.1123b6f0.png"},3634:function(l,v,i){l.exports=i.p+"img/1677217112874.83f897c9.jpg"},"55cd":function(l,v,i){l.exports=i.p+"img/1675064868770.a62cc455.png"},"561e":function(l,v,i){l.exports=i.p+"img/1676513061654.9cb1d7ef.png"},"56d5":function(l,v,i){l.exports=i.p+"img/1676885587690.51af393e.jpg"},"5c34":function(l,v,i){l.exports=i.p+"img/1676339195737.f39e36ff.jpg"},"88e1":function(l,v,i){l.exports=i.p+"img/1676345183309.97380a09.jpg"},9492:function(l,v,i){l.exports=i.p+"img/1676340046202.b262bce9.jpg"},9652:function(l,v,i){l.exports=i.p+"img/1676967088224.2933cd46.png"},"9a1f0":function(l,v,i){l.exports=i.p+"img/1675131639322.f49d94cd.png"},a61e:function(l,v,i){l.exports=i.p+"img/1676962931848.6c523013.png"},a744:function(l,v,i){l.exports=i.p+"img/1676964011637.d8e494ce.png"},ae07:function(l,v,i){l.exports=i.p+"img/1676340591965.d6382f81.jpg"},b76c:function(l,v,i){l.exports=i.p+"img/1676513900232.b5279116.jpg"},b88e:function(l,v,i){l.exports=i.p+"img/1676960295882.dbae60be.jpg"},be45:function(l,v,i){l.exports=i.p+"img/1676963814860.337fd285.png"},bfeb:function(l,v,i){l.exports=i.p+"img/1676340260988.d4da29b5.jpg"},c688:function(l,v,i){l.exports=i.p+"img/1676950037313.37998b5d.jpg"},c6dd:function(l,v,i){l.exports=i.p+"img/1676340838445.b6d18ef7.jpg"},c90f:function(l,v,i){l.exports=i.p+"img/1676339504968.6bd6a4a1.jpg"},de3e:function(l,v,i){l.exports=i.p+"img/1677217186821.2ec200ee.jpg"},e1bc:function(l,v,i){l.exports=i.p+"img/1676339914350.d02181ac.jpg"},ec9a:function(l,v,i){l.exports=i.p+"img/1676451515487.d22fd129.jpg"},ee96:function(l,v,i){"use strict";i.r(v);var a=function(){var l=this,v=l.$createElement;l._self._c;return l._m(0)},_=[function(){var l=this,v=l.$createElement,a=l._self._c||v;return a("section",[a("html",[a("head"),a("body",[a("h1",[l._v("2023面试题复习")]),a("h2",[l._v("1、java 基础")]),a("ul",[a("li",[a("p",[l._v("JDK和JRE的区别：")]),a("ul",[a("li",[a("p",[l._v("JDK是java工具包，里面包含了开发环境和运行环境。")])]),a("li",[a("p",[l._v("JRE是运行环境。")])])]),a("p",[l._v("换句话说，JDK里面包含了JRE。如果要运行java程序（这里指运行编译好了文件）可以直接安装JRE即可，如果是开发java程序，需要安装JDK。")])]),a("li",[a("p",[l._v("== 和 equals的区别：")]),a("ul",[a("li",[a("p",[l._v("== 对于基本数据类型和引用数据类型的效果是不一样的。")]),a("ul",[a("li",[l._v("基本数据类型：比较的是"),a("code",{pre:!0},[l._v("值")]),l._v("是否相同。")]),a("li",[l._v("引用数据类型：比较的是"),a("code",{pre:!0},[l._v("引用")]),l._v("是否相同。")])]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-java"}},[a("span",{pre:!0,attrs:{class:"hljs-type"}},[l._v("String")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-variable"}},[l._v("x")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-operator"}},[l._v("=")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[l._v('"string"')]),l._v(";\n"),a("span",{pre:!0,attrs:{class:"hljs-type"}},[l._v("String")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-variable"}},[l._v("y")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-operator"}},[l._v("=")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[l._v('"string"')]),l._v(";\n"),a("span",{pre:!0,attrs:{class:"hljs-type"}},[l._v("String")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-variable"}},[l._v("z")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-operator"}},[l._v("=")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[l._v("new")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-title class_"}},[l._v("String")]),l._v("("),a("span",{pre:!0,attrs:{class:"hljs-string"}},[l._v('"string"')]),l._v(");\nSystem.out.println(x == y);   "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[l._v("// true")]),l._v("\nSystem.out.println(x == z);   "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[l._v("// false")]),l._v("\nSystem.out.println(x.equals(y));  "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[l._v("// true")]),l._v("\nSystem.out.println(x.equals(z));  "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[l._v("// true")]),l._v("\n")])])]),a("li",[a("p",[l._v("equals的本质既是 == ， 只不过 string和 integet等包装类和其他特殊对象重写了equals方法。把它变成了值比较。")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-java"}},[a("span",{pre:!0,attrs:{class:"hljs-type"}},[l._v("Cat")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-variable"}},[l._v("c1")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-operator"}},[l._v("=")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[l._v("new")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-title class_"}},[l._v("Cat")]),l._v("("),a("span",{pre:!0,attrs:{class:"hljs-string"}},[l._v('"王磊"')]),l._v(");\n"),a("span",{pre:!0,attrs:{class:"hljs-type"}},[l._v("Cat")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-variable"}},[l._v("c2")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-operator"}},[l._v("=")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[l._v("new")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-title class_"}},[l._v("Cat")]),l._v("("),a("span",{pre:!0,attrs:{class:"hljs-string"}},[l._v('"王磊"')]),l._v(");\nSystem.out.println(c1.equals(c2));  "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[l._v("// false")]),l._v("\n")])]),a("p",[a("strong",[l._v("这样比较是 两个Object的引用，应为new了两次，创建了两个不同的引用空间，存储的内容是一样的，但是存储地址是不一样的。")])]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-java"}},[a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[l._v("public")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-type"}},[l._v("boolean")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[l._v("equals")]),a("span",{pre:!0,attrs:{class:"hljs-params"}},[l._v("(Object obj)")]),l._v(" {\n    "),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[l._v("return")]),l._v(" ("),a("span",{pre:!0,attrs:{class:"hljs-built_in"}},[l._v("this")]),l._v(" == obj);\n}\n")])]),a("p",[l._v("其实在没有重新equals方法时，调用的都是Object类中equals方法，它的实现就是上面的实现方式。")]),a("p",[l._v("而string类中，它重写了equals方法。把引用比较改成了内容比较。")])])])]),a("li",[a("p",[l._v("两个对象hashcode相同，那么他们的equals也一定为true吗？？")]),a("p",[l._v("不对，两个对象的hashcode 相同，equals也不一定为true。")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-java"}},[a("span",{pre:!0,attrs:{class:"hljs-type"}},[l._v("String")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-variable"}},[l._v("s1")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-operator"}},[l._v("=")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[l._v('"通话"')]),l._v(";\n"),a("span",{pre:!0,attrs:{class:"hljs-type"}},[l._v("String")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-variable"}},[l._v("s2")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-operator"}},[l._v("=")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[l._v('"重地"')]),l._v(";\n")])]),a("p",[l._v("上面这个两个字符串的hashcode是相同的，但是equals是一定不相同的。因为在散列表中hashcode相同，既两个键值对的hash值相等，hash值相等，并不一定得出值相等。")])]),a("li",[a("p",[l._v("final 在java中有什么作用：")]),a("ul",[a("li",[l._v("final修饰的类为最终类，是不能被集成的。")]),a("li",[l._v("final修饰的方法，不能被重写。")]),a("li",[l._v("final修饰的变量叫常量，常量必须被初始化，初始化后，就不能被修改。")])])]),a("li",[a("p",[l._v("java中的Math.round(-1.5)等于多少：")]),a("p",[l._v("等于 "),a("code",{pre:!0},[l._v("-1")]),l._v("，因为在数轴上取值时，中间值（0.5）向右取整，所以正（0.5）是往上取整的，负（0.5）直接被舍弃。")])]),a("li",[a("p",[l._v("string 是属于基本数据类型吗：")]),a("p",[l._v("不属于，基本数据类型只有八种，byte，boolean，char， short， int， float， long， double")])]),a("li",[a("p",[l._v("操作字符串都用那些类型，它们之间区别：")]),a("p",[l._v("操作字符串的类：String，StringBuffer， StringBudiler")]),a("ul",[a("li",[l._v("String：声明的是不可变的对象，可以通过源码发现，String类是用final修饰过的。每次修改字符串的值，会重新创建一个对象。")]),a("li",[l._v("StringBuffer和StringBuilder是在原有基础上进行修改的，不会重新新建对象，")]),a("li",[l._v("StringBuffer是线程安全的，StringBuilder是线程不安全，但是StringBuilder的性能好于StringBuffer，所以在单线程下，推荐使用StringBuilder，在多线程换下，推荐使用StringBuffer。")])])]),a("li",[a("p",[l._v('String str = "i" 和 String str1 = new String("i") 的区别：')]),a("p",[l._v('两个使用 == 比较时，为false， 因为内存分配方式不一样，String str = “i”的方式，java虚拟机会分配常量池空间中，而String str1 = new String("i") 会被分配到堆内存中。')])]),a("li",[a("p",[l._v("如何将字符串反转：")]),a("p",[l._v("使用StringBuffer或StringBuilder 的reveres()方法")])]),a("li",[a("p",[l._v("String中常用的方法：")]),a("ul",[a("li",[l._v("indexOf：返回指定字符的索引。")]),a("li",[l._v("charAt：将字符串转换字符数组。")]),a("li",[l._v("replace：字符串替换。")]),a("li",[l._v("trim：去除字符串两端的空白。")]),a("li",[l._v("split：按照要求分割字符串，返回字符串数组。")]),a("li",[l._v("getBytes：返回字节数组。")]),a("li",[l._v("length：返回字符串的长度。")]),a("li",[l._v("equals：比较。")]),a("li",[l._v("subString：字符串的截取。")])])]),a("li",[a("p",[l._v("抽象类中一定存在抽象方法吗：")]),a("p",[l._v("不一定，抽象类中不一定存在抽象方法。但是，存在抽象方法的类，一定是抽象类。")])]),a("li",[a("p",[l._v("普通类和抽象类的区别：")]),a("ul",[a("li",[l._v("普通类不能包含抽象方法，可以被实例化。可以被final修饰。")]),a("li",[l._v("抽象类可以存在抽象方法，但是不能被实例化。不能被final修饰，抽象类中，可能存在抽象方法，它需要被其他类继承来是实现当中的抽象方法，如果可以被final修饰的话，那么就不能被基础，那其中抽象方法永远不能被实现。")])])]),a("li",[a("p",[l._v("抽象类和接口的区别：")]),a("ul",[a("li",[l._v("关键词和实现方式的区别：接口和继承的关键词不同，抽象类采用的extends来继承的。接口采用的implements来实现接口的。")]),a("li",[l._v("抽象类中可以存在构造方法，而接口中不能存在构造方法。")]),a("li",[l._v("实现数量：一个类可以实现多个接口，一个类只能继承一个抽象类。")]),a("li",[l._v("访问权限修饰符：接口中默认采用的pubilc修饰，抽象类中采用的与普通类一样。")])])]),a("li",[a("p",[l._v("Java中IO流：")]),a("p",[l._v("按照功能可以分为：输入流（input）和输出流（output）")]),a("p",[l._v("按照类型可以分为：字节流（char）和字符流（byte） --\x3e 字节流和字符流的区别：字节流是按照8位传输，以字节为单位的输入输出数据，字符流是按照16位传输，以字符为单位的输入输出数据。")]),a("ul",[a("li",[l._v("BIO：block IO 同步阻塞IO，就是平时我们使用的IO模式，特点：模式简单，方便使用，并发处理能力低。")]),a("li",[l._v("NIO：new IO 同步非阻塞IO，就是传统IO的升级，serve 和 client 通过channel通讯，实现了多路复用。")]),a("li",[l._v("AIO：asynch IO 异步非阻塞IO，是NIO的升级，是异步非阻塞IO，异步IO的操作是基于事件和回调机制。")])])]),a("li",[a("p",[l._v("throw 和的 throws的区别：")]),a("ul",[a("li",[l._v("throw：用来抛出一个具体异常。")]),a("li",[l._v("throws：在方法上声明，可以要抛出一个异常。")])])]),a("li",[a("p",[l._v("final 和 finally finalize 的区别：")]),a("ul",[a("li",[l._v("final：修饰符，可以修饰 变量，方法， 类。修饰变量为常量，修饰方法不能被重写，修饰类不能被继承。")]),a("li",[l._v("finally：关键字，常用于异常处理的结构中，一般会使用它关闭流操作。")]),a("li",[l._v("finalize：一个方法，Object的一个方法，垃圾回收来调用的。一般调用System.gc 时，垃圾回收方法会调用该方法。")])])])]),a("h2",[l._v("2、集合")]),a("h3",[l._v("2.1、java的容器：")]),a("p",[a("img",{attrs:{src:i("55cd"),alt:"image-20230130154750770"}})]),a("h3",[l._v("2.2、collection 和 collectons 的区别：")]),a("ul",[a("li",[l._v("collection是java的集合接口，是一个顶级接口，里面提供了集合进行操作的通用方法，collection接口的意义是为了各种集合提供最大化的统一操作方式，其中集成就有 list 和 set集合。")]),a("li",[l._v("collections 是集合操作的一个工具类，里面提供了一些静态方法，用于集合元素的排序，查询等方法。")])]),a("h3",[l._v("2.3、List set map 的区别：")]),a("table",[a("thead",[a("tr",[a("th",[l._v("比较")]),a("th",[l._v("list")]),a("th",[l._v("set")]),a("th",[l._v("Map")])])]),a("tbody",[a("tr",[a("td",[l._v("继承接口")]),a("td",[l._v("collection")]),a("td",[l._v("collection")]),a("td")]),a("tr",[a("td",[l._v("常见的实现类")]),a("td",[l._v("ArrayList， linkedList，vector")]),a("td",[l._v("HashSet，LinkedHashSet，TreeSet")]),a("td",[l._v("HashMap，HashTable")])]),a("tr",[a("td",[l._v("常见的方法")]),a("td",[l._v("add，remove，clear，get，size")]),a("td",[l._v("add，remove，size")]),a("td",[l._v("put，get，clear，keySet， values")])]),a("tr",[a("td",[l._v("元素")]),a("td",[l._v("可以重复")]),a("td",[l._v("不可以重复，")]),a("td",[l._v("不可以重复")])]),a("tr",[a("td",[l._v("顺序")]),a("td",[l._v("有序")]),a("td",[l._v("无序")]),a("td",[l._v("无序")])]),a("tr",[a("td",[l._v("线程安全")]),a("td",[l._v("Vecctor安全")]),a("td"),a("td",[l._v("hashTable安全")])])])]),a("h3",[l._v("2.4、array list的实现")]),a("p",[l._v("array list 底层采用数组的方式实现，是线程不安全的，数组实现的方式具有，查询修改快，插入和删除较慢，因为在数组的结构是一个连续的内存空间，在中间做插入和删除的操作时，在被删除或插入的位置后面的元素都要进行移动。array list的扩容方式是根据1.5倍扩容的。")]),a("h3",[l._v("2.5、HashMap和HashTable的区别：")]),a("ul",[a("li",[l._v("HashMap：去掉了HashTable的contants方法，但是添加了contantsValue和contantsKey方法。")]),a("li",[l._v("HashTable同步的，而HashMap是非同步的，效率上hashMap要高一些。")]),a("li",[l._v("HashMap允许空键值，而HashTable不允许。")]),a("li",[l._v("HashTable在所有的操作添加了synchronized关键字。")]),a("li",[l._v("ConcurrentHashMap：是线程安全的集合，它是在hash桶上保证了线程安全，每一次对一个桶添加锁，")])]),a("h3",[l._v("2.6、hashmap 和 treemap的区别：")]),a("ul",[a("li",[l._v("hashmap中key是无序，插入，删除和定位元素较快。")]),a("li",[l._v("treemap中，可以按照key进行排序。")])]),a("h3",[l._v("2.7、HashMap的实现原理：")]),a("p",[l._v("概述：hashMap是基于hash表实现的map接口的非同步实现。允许使用null值作为key和value的方式存储，但是不能保存存储key的顺序，特别是在数据很大时，每一个key的存储位置不能保证不变。")]),a("p",[l._v("hashMap的数据结构：在java中，最基本的数据结构就只有两种，一个是数组，一个是引用（模拟指针）。所有的数据结构都是采用这两种基本数据结构组合而成，hashMap也不例外，HashMap就是一个链表散列的数据结构，数组+链表的结构。")]),a("p",[l._v("当我们往HashMap中使用put添加元素时：")]),a("ol",[a("li",[l._v("根据添加key计算key的hashCode值，根据Hashcode值来确定该元素存储在数据的哪一个索引上。")]),a("li",[l._v("如果该索引上存储了其他元素时：那么这个位置存储的元素将以链表的方式进行存储。新添加的元素会被放在链表的表头，最先放的元素会被存在链表的表尾。如果数组中没有存放元素，那么元素将直接存在数组的位置。")])]),a("p",[l._v("需要注意的是：在JDK1.8中对HashMap中实现了优化，当链表中的节点数据超过8个之后时，该链表就会转为红黑树结构，这样可以提高查询的效率。")]),a("ul",[a("li",[a("p",[l._v("hashMap底层注意：")]),a("ul",[a("li",[a("p",[l._v("hashmap是懒加载，只有在第一次put元素1时，才会创建数组。")])]),a("li",[a("p",[l._v("hashmap的默认长度是16，如果小于16，最终hashmap的长度为将为16，一般默认指定hashmap的长度，底层hash表的长度并不是指定的长度，会比指定的长度长一些。")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-java"}},[a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[l._v("static")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[l._v("final")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-type"}},[l._v("int")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[l._v("tableSizeFor")]),a("span",{pre:!0,attrs:{class:"hljs-params"}},[l._v("("),a("span",{pre:!0,attrs:{class:"hljs-type"}},[l._v("int")]),l._v(" cap)")]),l._v(" {\n    "),a("span",{pre:!0,attrs:{class:"hljs-type"}},[l._v("int")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-variable"}},[l._v("n")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-operator"}},[l._v("=")]),l._v(" cap - "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[l._v("1")]),l._v(";\n    n |= n >>> "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[l._v("1")]),l._v(";\n    n |= n >>> "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[l._v("2")]),l._v(";\n    n |= n >>> "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[l._v("4")]),l._v(";\n    n |= n >>> "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[l._v("8")]),l._v(";\n    n |= n >>> "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[l._v("16")]),l._v(";\n    "),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[l._v("return")]),l._v(" (n < "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[l._v("0")]),l._v(") ? "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[l._v("1")]),l._v(" : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[l._v("1")]),l._v(";\n}\n")])]),a("p",[l._v("该方法作用是获取一个2^n次方数，是一个大于接近于你指定的那个长度。如：指定长度为1000，而实际长度为1024的长度。")]),a("p",[l._v("cap - 1的作用就是为了防止传递长度就是2^n次方数，经过上面的运行避免出现了2^(n+1)次方")])]),a("li",[a("p",[l._v("hashmap的默认加载因子是0.75。一般hashmap的hash表的元素个数达到 长度 * 0.75 后，就会进行扩容。每一次扩容是一个非常耗时的过程，需要重新计算每一个元素的hashcode值，重新分配元素在hash表的位置。")])]),a("li",[a("p",[l._v("hashmap的长度为啥是2^n次方：主要是与hash的寻址有关，都知道，hashmap添加元素时，是按照key的hashcode值来确定key在hash表的位置（具体公式：i = (n - 1) & hashcode）。其实简单的来说，这个公式就是一个取模的操作，但是取模的速度没有&运算的速度快，所以才使用&操作。但是要使&运算，需要满足一个条件（a % b）= a & (b - 1)，只有在b为2^n次方时，才成立，所以hahsmap的长度才是2^n次方。")])])])])]),a("h3",[l._v("2.8、HashSet的原理：")]),a("ul",[a("li",[l._v("HashSet的底层是HashMap实现的。")]),a("li",[l._v("HashSet的值存储在HashMap的Key上。")]),a("li",[l._v("HashMap的Value统一存储了"),a("code",{pre:!0},[l._v("PRESENT")]),l._v("。")])]),a("h3",[l._v("2.9、ArrayList 和 linkedList的区别：")]),a("p",[l._v("最明显区别是底层结构的不同，ArrayList底层是由数组的实现的，支持随机访问，linkedList是由双向循环链表实现的，不支持随机访问。")]),a("h3",[l._v("2.10、ArrayList 和 Vector 的区别：")]),a("ul",[a("li",[l._v("Vetctor是同步的，ArrayList是非同步的，ArrayList的效率更高一些。")])]),a("h3",[l._v("2.11、Array和ArrayList的区别：")]),a("ul",[a("li",[l._v("Array可以存储基本数据类型和对象，而ArrayList只能存储对象类型。")]),a("li",[l._v("Array需要指定大小，而ArrayList的大小是固定的。")]),a("li",[l._v("Array没有提供ArrayList那么多功能，比如：addAll等。")])]),a("h3",[l._v("2.12、在queue 中poll 和 remove的区别：")]),a("ul",[a("li",[l._v("poll 是从队列中取出一个元素，如果取出失败了，返回的是一个null。")]),a("li",[l._v("remove是从队列中删除一个元素，但是也会返回删除成功的这个元素，如果删除失败，就会抛出异常。")])]),a("h3",[l._v("2.13、线程安全集合")]),a("ul",[a("li",[l._v("vector：比arrayList多了一个同步机制，线程安全。效率低，现在已经不怎么使用了。")]),a("li",[l._v("statck：堆栈类，先进后出。")]),a("li",[l._v("hashTable：比hashMap多了一个同步机制。")]),a("li",[l._v("enumeration：枚举")])]),a("h3",[l._v("2.14、iterator怎么使用，有什么特点：")]),a("p",[l._v("在java中iterator使用比较简单，只能单向移动。")]),a("ol",[a("li",[l._v("使用iterator方法，获取一个对象的迭代器对象。")]),a("li",[l._v("使用迭代器中next方法，获取下一个元素。")]),a("li",[l._v("使用hasNext方法检查迭代器中是否存在下一个元素。")]),a("li",[l._v("使用remove方法可以将迭代器中新返回的元素删除。")])]),a("h3",[l._v("2.15、iterator和listIterator有区别:")]),a("ul",[a("li",[l._v("iterator：可以用来变量list 和 set 集合，但是 listIterator只能用来遍历list。")]),a("li",[l._v("Iterator对集合只能单向并且只能向前遍历，listIterator可以向前也可以向后遍历。")])]),a("h2",[l._v("3、多线程")]),a("h3",[l._v("3.1、并行和并发区别：")]),a("ul",[a("li",[l._v("并行：是指两个或者多个事件在同一时刻发生，是在不同实体上的多个事件。")]),a("li",[l._v("并发：是指两个或者多个事件在同一时间间隔发生，是在同一个实体上的多个事件。")])]),a("h3",[l._v("3.2、线程和进程区别：")]),a("ul",[a("li",[l._v("进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在运行过程中拥有独立的内存单元。在多个线程之间，共享内存资源，减少切换次数，从而提高效率。")]),a("li",[l._v("线程是一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位，同一个进行中，可以存在多个线程并发执行。")])]),a("h3",[l._v("3.3、创建线程的几种方式：")]),a("ol",[a("li",[l._v("继承Thread类创建线程类：")])]),a("ul",[a("li",[l._v("定义Thread的子类，并重写run方法，在run方法中就表示线程需要执行事件。run方法也叫执行体。")]),a("li",[l._v("创建Thread子类的实例，创建线程对象。")]),a("li",[l._v("调用线程对象 start方法来启动该线程。")])]),a("ol",{attrs:{start:"2"}},[a("li",[l._v("通过runnable接口来创建线程类：")])]),a("ul",[a("li",[l._v("定义runnable接口的实现类，并实现run方法，在run方法中就表示线程需要执行的事件，run方法也叫执行体。")]),a("li",[l._v("创建runnable实现类的实例，并创建Thread 对象，将runnable实例交给 Thread 对象。")]),a("li",[l._v("调用线程对象的 start方法来启动线程。")])]),a("ol",{attrs:{start:"3"}},[a("li",[l._v("通过callable 和 future创建线程：")])]),a("ul",[a("li",[l._v("创建callable接口的实现类，并实现call方法，在call方法中就表示线程需要执行的事件，call方法也叫执行体。call是存在返回值和异常处理的。")]),a("li",[l._v("创建Callable实例，使用FutureTask类来包装Callable对象。")]),a("li",[l._v("使用furureTask对象作为Thread对象target创建并启动线程。")]),a("li",[l._v("调用furureTask对象get方法获取call方法执行返回值。")])]),a("h3",[l._v("3.4、runnable和 callable的区别：")]),a("ul",[a("li",[l._v("runnable接口中run放没有返回值，不能抛出异常，异常只能在内部处理，只是单纯的去执行run方法中代码。")]),a("li",[l._v("callable中call有返回值，可以抛出异常，返回值是一个泛型，和furure，furureTask配合可以获取异步执行结果。")])]),a("h3",[l._v("3.5、线程状态：")]),a("p",[l._v("线程通常存在五种状态：创建，就绪，运行，阻塞，死亡")]),a("ul",[a("li",[l._v("创建：在生成线程对象，并没有调用该对象的start方法时，该线程就处于创建状态。")]),a("li",[l._v("就绪状态：在调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程（就是CPU为调度到该线程，未执行时），此时该线程就进入就绪状态。或者在线程运行之后，从等待或者睡眠中回来之后，也会进入就绪状态。")]),a("li",[l._v("运行状态：线程调度程序将该线程设置成当前线程，此时该线程就进入了运行状态，开始运行run方法中的代码逻辑。")]),a("li",[l._v("阻塞状态：线程正在运行中时，被暂停，通常是为了等待某一个时间发生后再运行（如：资源准备就绪）。sleep，suspend，wait等方法都可以导致线程进入阻塞状态。")]),a("li",[l._v("死亡状态：如果一个线程的run方法执行结束后，或者调用了stop方法后，该线程就会死亡，对于已经死亡的线程无法在使用start方法进入就绪状态。")])]),a("h3",[l._v("3.6、sleep和wait的区别：")]),a("ul",[a("li",[l._v("sleep：实现线程类Thread的静态方法，让调用线程进入睡眠状态，让出执行机会，释放CPU使用权，等待睡眠时间结束后，该线程会进入就绪状态，和其他线程竞争CPU使用权，因为sleep是静态方法，它不能改变对象锁机制，当一个synchronized代码块中调用了sleep方法，线程虽然进入睡眠状态，但是对象的锁机制没有释放，其他线程依无法访问这个对象。"),a("strong",[l._v("注意的是，并不不会释放锁，只会释放cpu资源。")])]),a("li",[l._v("wait：该方法是Object类中的方法，当一个线程执行到了wait方法时，它进入一个和该对象的等待池，同时释放该对象的锁机制，使得其他线程可以访问到该对象，可以通过该notify和notiifyAll方法来唤醒等待的线程。")])]),a("h3",[l._v("3.7、notify 和 notifyAll的区别：")]),a("ul",[a("li",[l._v("如果线程调用了wait方法，那么该线程就会进入一个等待池中，等待池中的线程不会去抢该对象的锁。")]),a("li",[l._v("当有线程调用了对象notifyAll（唤醒等待池所有线程）方法，或者notify（等待池中的某一个线程）方法，被唤醒的线程便进入该对象的锁池中，锁池中的线程获取抢该对象锁，也就是说，调用联notify方法后，或会唤醒一个线程从等待池到该对象的锁池中，等待抢到该对象的锁。")]),a("li",[l._v("优先级高的线程竞争到对象锁的概率较大，假如某一个线程没有竞争到该对象锁，它还会在锁池中，唯有线程调用了wait方法，线程才会重新进入等待池中。而竞争到对象锁的线程则会继续向下执行，直到执行完synchronized代码块，它才会释放对象锁，这时锁池中的线程才会继续竞争对象锁。")])]),a("h3",[l._v("3.8、线程的run方法和start方法的区别：")]),a("ul",[a("li",[a("p",[l._v("每一个线程是通过特定的Thread对象所对应run方法来完成操作的，run方法被叫做线程体。而start方法是用来启动一个线程的。")])]),a("li",[a("p",[l._v("start方法用来启动一个线程，实现了真正多线程运行，这是无需等待run方法中代码执行完毕，可以执行运行下面的代码逻辑。这是此时线程会进入就绪状态，并没有运行，然后通过线程Thread中run方法来完成运行状态。这里run方法称为线程体。run方法运行结束，此线程也就终止了，然后CPU在调度其他线程。")])]),a("li",[a("p",[l._v("run方法是线程里的，只是线程里的一个函数，而不是多线，如果直接调用run方法就是相当于调用一个普通的函数，所以在执行多线程时，必须要调用start方法。")])])]),a("h3",[l._v("3.9、创建线程池的几种方式：")]),a("ul",[a("li",[a("p",[l._v("newFixedThreadPool：创建一个固定长度线程池，每当提交一个任务就创建一个线程，直到到达该线程池中的最大数量时，这时线程规模将不在发生变化，当线程发生未预计的错误而结束时，线程池会补充一个新的线程。")])]),a("li",[a("p",[l._v("newCachedThreadPool：创建一个可以缓存的线程池，如果线程池超过了处理需求时，将自动回收空闲线程，而当需求增加时，则可以自动新增线程，线程池的规模不存在限制。")])]),a("li",[a("p",[l._v("newSingleThreadPool：创建一个单线程Executor，如果这个线程在执行中异常结束时，会创建一个新的线程，它的特点是能确保依照列表中的顺序来串行执行。")])]),a("li",[a("p",[l._v("newScheduledThreadPool：创建一个固定长度的线程池，而且是延时或定时的方式来执行，类似的定时任务的线程。")])]),a("li",[a("p",[l._v("线程池的状态：")]),a("p",[l._v("线程池有五种状态：running，shutDown，stop，tidying，terminated")]),a("p",[a("img",{attrs:{src:i("9a1f0"),alt:""}})])])]),a("h3",[l._v("3.10、线程池中的submit和execute方法的区别：")]),a("ul",[a("li",[l._v("两个方法接受参数不一样。execute（runnable），submit（callable）/ submit（runnable）")]),a("li",[l._v("submit有返回值，execute没有返回值。")]),a("li",[l._v("submit方便处理异常。")])]),a("h3",[l._v("3.11、在java中如何保证多线程运行安全：")]),a("ul",[a("li",[l._v("原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作。")]),a("li",[l._v("可见性：一个线程对主内存的修改，可以及时的被其他线程看到。（当多个线程访问同一个变量时，其中一个线程修改了该变量，其他线程可以立即看到修改值）")]),a("li",[l._v("有序性：一个线程在观察其他线程中的指令执行顺序，由于指令重排序，该观察的结果一般是杂乱无序的。（就是执行程序的顺序就是按照代码的先后顺序来执行）")])]),a("h3",[l._v("3.12、多线程中锁升级原理：")]),a("p",[l._v("在java中，锁存在4中状态，级别从低到高：无状态锁，偏向锁，轻量级锁，重量级锁，这几种状态会随着竞争情况逐渐升级。锁可以升级但是不能降级。")]),a("p",[l._v("锁升级的过程：")]),a("p",[a("img",{attrs:{src:i("0aed"),alt:""}})]),a("h3",[l._v("3.13、什么是死锁：")]),a("p",[l._v("死锁是两个或两个以上线程在执行过程中，由于竞争资源或者由于彼此通信而造成的阻塞状态。如果不采用外界条件干预的话，它们将一直阻塞下去，此时系统处于死锁状态。（就是在多个线程之间，一个线程获取的锁，但是该线程一直不释放该锁，一直获取着，但是其他线程也获取不到锁，就无法执行任务逻辑，造成整个系统处于无法执行任务的状态。）")]),a("h3",[l._v("3.14、如果防止死锁：")]),a("ul",[a("li",[l._v("避免一个线程同时获取多个锁。")]),a("li",[l._v("避免一个线程在锁内同时占用多个资源，尽量保证某一个锁占用一个资源。")]),a("li",[l._v("尝试使用定时锁。")])]),a("h3",[l._v("3.15、ThreadLocal是什么，有哪些使用场景？")]),a("p",[l._v("线程局部变量，属于线程本身，不在多个线程之间共享，任何线程局部变量一旦在工作完成后没有释放，java应用就可能存在内存泄漏的风险。")]),a("h3",[l._v("3.16、synchronized的底层原理")]),a("p",[l._v("synchonized是用来保证线程同步的，可以作用在方法上和代码块上，同一时刻只有一个线程可以进行该方法或者代码块中执行，同时还保证了共享内存变量的可见性。")]),a("p",[l._v("java中每一个对象都可以作为锁，这是sychronized实现同步的基础：")]),a("ul",[a("li",[l._v("普通同步方法：锁的是当前实例对象。")]),a("li",[l._v("静态同步方法：锁的是当前类对象。")]),a("li",[l._v("同步代码块：锁的是代码块里面的对象。")])]),a("h3",[l._v("3.17、synchronized和volatile的区别：")]),a("ul",[a("li",[l._v("volatile的本质是告诉JVM在当前内存（寄存器）中的值是不确定的，需要从主内存中读取。synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程访问进入阻塞。")]),a("li",[l._v("volatile仅使用在变量上，synchronized可以在变量，方法，代码块。")]),a("li",[l._v("volatile只能实现变量的修改可见性，不能保证原子性。synchronized不仅可以保存变量的修改可见性，也能保证原子性。")]),a("li",[l._v("volatile不会造成线程阻塞。synchronized造成线程阻塞。")]),a("li",[l._v("volatile标记的变量不会被编译器优化。synchronized标记变量可以被编译器优化。")])]),a("h3",[l._v("3.18、synchronized 和 lock的区别：")]),a("ul",[a("li",[l._v("synchronized是java中的一个关键字，lock是就java的一个类。")]),a("li",[l._v("synchronized是无法获取的锁状态，执行结束后，自动释放锁状态。lock是可以获取锁状态的，需要手动释放锁，否则会造成死锁的情况。")]),a("li",[l._v("synchronized的锁可重入，不可中断，非公平。lock锁可重入，可以判断，可公平。")]),a("li",[l._v("synchronized适用于少量代码逻辑。lock锁适用于大量的同步代码逻辑。")])]),a("h3",[l._v("3.19、atomic的原理:")]),a("p",[l._v("atomic包中基本的特征就是在多线程环境下，当多个线程同时对单个变量进行操作时，具有排他性，当多个线程对一个变量进程修改更新时，仅有一个线程才可以操作，而其他线程像自旋锁一样，继续尝试，一直等待尝试成功。")]),a("p",[l._v("atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法，unsafe这个类中包含了大量的c代码操作。里面包含了很对直接分配内存和原子操作的调用，它之所以标记为非安全，是警告使用者小心使用，如果使用不当，会造成一些严重的后果。")]),a("h3",[l._v("3-20、sleep和wait方法的区别：")]),a("ul",[a("li",[l._v("sleep方法是线程睡眠，是Thread类中的静态方法，调用该方法后，线程会进行睡眠，释放cpu调度权，但是不会释放锁对象。")]),a("li",[l._v("wait是Object中的实例方法的，调用后，线程会释放cpu的调度权，也会释放锁对象，线程会进入等待池中，等待线程被唤醒，唤醒后线程就进入锁池，准备抢锁。")])]),a("h3",[l._v("3-21、volatile：")]),a("p",[l._v("volatlie是保证修饰变量的可见性，可能保证同一个变量在多线程中的可见性，简单的来说就是在多个线程操作这个变量时，只有一个线程可以修改，但是修改后值，在其他线程中是可见的。")]),a("ul",[a("li",[l._v("修饰的变量不存在的多个线程中的副本中，是直接存储在内存中的。")]),a("li",[l._v("会禁止指令的重排序。")])]),a("p",[l._v("volatile 提供了happens - before 的保证，确保了一个线程修改，多对其他线程是可见的。")]),a("p",[l._v("在java中，除了 long 和 double类型之外，所以的基本类型的读和赋值操作都是原子性的。而 long 和 double 是64位的，jvm为分配两个32位的空间来存储这两个类型的数据，所以不具有原子操作。会产生字撕裂的问题。当你使用long 和 double是使用volatiile修饰后，在读和赋值上就具有原子操作。")]),a("h3",[l._v("3.22、线程调度级别和的线程控制：")]),a("ul",[a("li",[l._v("线程调度级别：在java中，线程的优先级是无法控制的，不过，优先级高的线程，在获取的cpu的调度权的概率会比较大，并不是优先级低的线程就没有执行权利。线程的优先级是从1 - 10之间的整数来设置的，数值越大，优先级越高，默认优先级是5。在一个线程中又开启了一个线程，这个新开启的线程被称为子线程，外面的线程称为父线程，子线程的优先级与父线程的优先级一致。")]),a("li",[l._v("线程控制： "),a("ul",[a("li",[l._v("sleep睡眠，不会释放锁，但是会释放cpu。")]),a("li",[l._v("join：线程加入。")]),a("li",[l._v("yield：线程礼让。")]),a("li",[l._v("setDaemon：线程守护。")]),a("li",[l._v("stop：停止线程。")]),a("li",[l._v("interrupt：")])])])]),a("h3",[l._v("3.23、stop 和 suspend：")]),a("ul",[a("li",[l._v("stop：反对使用stop，线程不安全。因为它会解除由该线程获取到所有的锁定，如果对象处于一种不连贯的状态，那么其他线程在那种情况下，检查修改它们。")]),a("li",[l._v("suspend：方法容易发生死锁，在调用suspend的时候，线程会停下来，但是不会释放当前的线程获取的锁，其他线程都还是不能访问被锁定的资源，")])]),a("h3",[l._v("3.24、什么是cas")]),a("p",[l._v("CAS就是compare and swap的缩写，也就是是比较交换。cas是一种基于锁的操作，是一个乐观锁。")]),a("p",[l._v("在java中，分为乐观锁和悲观锁。")]),a("ul",[a("li",[l._v("悲观锁：是将资源锁住，等一个之前获取到锁的线程来释放锁之后，下一个线程才可以进行访问。")]),a("li",[l._v("乐观锁：通过某一种方式来不加锁处理资源，比如通过记录version来获取资源，性能有很大的提升。")])]),a("p",[l._v("CAS里面包含三个操作数，内存位置（v），期望原值（A），新值（B），在修改的时候，就会先检查内存中的值是否于期望原值是否一致，如果一致，就将内存中存储的值改成新值，如果不一致就不能修改。")]),a("p",[l._v("在CAS里面获取数据是通过无限循环来实现，若在一次循环中，线程1获取到内存中的值被线程2修改了，那么a线程需要自旋，在下一次循环时才能执行线程1的操作。")]),a("h3",[l._v("3.25、cas的问题：")]),a("ul",[a("li",[a("p",[l._v("cas容易造成ABA的问题：")]),a("p",[l._v("ABA的问题是，一个线程将内存中的的一个变量A修改成B，然后又修改成A，但是在CAS算法中，发现变量A没有发生任何变化，但是其实变量已经被修改过了，为了解决这样的问题，可以添加version，就是每操作一次变量，version就会加一。")])]),a("li",[a("p",[l._v("不能保证代码块的原子性：")]),a("p",[l._v("cas只能保证一个变量的具有原子行，不能保证整个代码块具有原子性，比如：有三个CAS的变量，需要同时修改这个三个变量才算成功，反之就是失败，如果使用的CAS的话，就不行，需要使用synchronized来解决。")])]),a("li",[a("p",[l._v("CAS会造成CPU利用率增加：")]),a("p",[l._v("CAS内部是采用无限循环来实现的，如果当一个线程一直没有获取到状态，cpu资源会一直的被占用。")])])]),a("h3",[l._v("3.26、AQS：")]),a("p",[l._v("AQS是 abustact queued synchronzied的简称，它是一个java底层同步的工具类，用一个int类型的变量来表示同步状态，并提供了一系列的CAS操作类实现这个同步状态。")]),a("p",[l._v("AQS是用来构建锁和同步的一个框架，使用AQS可以构建出来大量的同步器，比如：读写锁等。")]),a("ul",[a("li",[l._v("AQS支持的同步方式： "),a("ul",[a("li",[l._v("独占式。")]),a("li",[l._v("共享式。")])])])]),a("p",[l._v("ReentrantLock：就是读写锁的一种，就会在读和写的时都会添加锁，这样效率不高，")]),a("h3",[l._v("3.27、高并发处理指标：")]),a("ul",[a("li",[l._v("响应时间：系统对请求作出响应时间。")]),a("li",[l._v("吞吐量：单位时间内处理请求的数量。")]),a("li",[l._v("qps：每秒请求的个数。")]),a("li",[l._v("并发用户访问数：同时用户存在线的并发用户。")])]),a("h2",[l._v("4、反射")]),a("h3",[l._v("4.1、什么是反射：")]),a("p",[l._v("反射主要是指程序可以访问，修改，检测它本身的状态或行为的一种能力。")]),a("p",[l._v("java反射机制主要提供了以下功能：")]),a("ul",[a("li",[l._v("在运行时判断任意一个对象的所属类。")]),a("li",[l._v("在运行时可以构造任务一个类的对象。")]),a("li",[l._v("在运行时判断任意一个类的所有属性和方法。")]),a("li",[l._v("在运行时可以调用任意一个对象的方法。")])]),a("h3",[l._v("4.2、什么是序列化：")]),a("p",[l._v("简单的来说，序列化就是把内存的对象（属性，方法等信息）状态保存，也可以把保存的对象状态恢复到内存。")]),a("p",[l._v("什么情况下需要序列化：")]),a("ul",[a("li",[l._v("当你想把内存中的对象状态持久化到一个文件时，或者持久化到其他地方的时候。")]),a("li",[l._v("当你想把对象在网络中传递时。")])]),a("h3",[l._v("4.3、什么是动态代理，应用：")]),a("ul",[a("li",[l._v("动态代理：当想要给实现了某一个接口中的方法添加一些新功能时，比如 日志，事务等，就可以创建一个代理类，这个类不仅还包括原来接口的功能，而且还在原有基础上添加了一些额外的功能。这个代理类并不是定义好的，而是动态生成的。具有解耦，灵活，易扩展。")]),a("li",[l._v("动态代理的应用： "),a("ul",[a("li",[l._v("spring aop")]),a("li",[l._v("spring的事务")]),a("li",[l._v("添加权限")]),a("li",[l._v("添加日志")])])])]),a("h3",[l._v("4.4、如果实现动态代理：")]),a("ol",[a("li",[l._v("首页必须要定义一个接口，还要有一个invocationhandler（将实现接口的类对象传递给它）处理类。")]),a("li",[l._v("需要一个代理工具类Proxy（调用他newInstance可以生产代理对象）。")]),a("li",[l._v("利用invocation handler 拼接代理类源码，并将其编译生产代理类二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。")])]),a("h3",[l._v("4.5、深拷贝和浅拷贝的区别：")]),a("ul",[a("li",[l._v("浅拷贝：只是复制了对象引用地址，两个对象还是指向同一块内存空间，所以修改一个对象的值，另一个对象的值也会改变。")]),a("li",[l._v("深拷贝：就是将对象和对象值都复制出来并获取一个新对象，两个对象的地址是指向不同内存空间，修改一个对象的值，另一个对象不会发生变化。")])]),a("h2",[l._v("5、web")]),a("h3",[l._v("5.1、session和cookie的区别：")]),a("ul",[a("li",[a("p",[l._v("对象不同：")]),a("ul",[a("li",[l._v("cookie是保存在客户端，是针对每一个网站的信息，每一个网站只能对应一个，其他网站是不能访问的，")]),a("li",[l._v("session是保存在服务端的，是针对每一个用户的，只有客户端才能访问。")])])]),a("li",[a("p",[l._v("存储数据大小不同：")]),a("ul",[a("li",[l._v("cookie：一个cookie存储的数据不超过3k。")]),a("li",[l._v("session：可以存任意数据，是存储在服务器上的，当session数据太多时，服务器可选择性清理。")])])]),a("li",[a("p",[l._v("生命周期的不同：")]),a("ul",[a("li",[l._v("cookie的生命周期是从浏览器打开开始，到页面关闭结束。")]),a("li",[l._v("session的生命周期是隔间的，如果用户在30s没有访问或者更新session的操作，session就会失效。")])])]),a("li",[a("p",[l._v("存储数据类型不同：")]),a("p",[l._v("虽然session和cookie存储的数据格式都是key-value的方式。")]),a("ul",[a("li",[l._v("cookie只能存储字符串。")]),a("li",[l._v("session可以Object的类型。")])])]),a("li",[a("p",[l._v("安全性：")]),a("ul",[a("li",[l._v("cookie不是很安全。因为存储在本地，可以会被篡改。")]),a("li",[l._v("相对安全。")])])])]),a("h3",[l._v("5.2、session的工作原理：")]),a("p",[l._v("session的工作原理是客户端在登录完成后，服务器会创建一个对应的session，在session创建完成后，会把session id 发给客户端，客户端在把获取的session存储在浏览器中，这样每一次客户端访问服务端时，会携带浏览器的session id ，这样服务端就可以根据session id 找对之前创建的session 信息。")]),a("h2",[l._v("6、spring")]),a("h3",[l._v("6.1、为啥使用spring：")]),a("p",[l._v("解决应用开发的复杂性，使用基本的java bean代理原来EJB，并提供了更多的企业功能服务。简单的来说，spring是一个轻量级的控制反转和面向切面编程的容器框架。")]),a("ul",[a("li",[l._v("轻量：从大小于开销两个方面来说，spring都是轻量级的，一个完成的spring框架可以在只有1M多的jre里面发布。spring是一个非浸入式的框架，其中spring中对象并不依赖spring的特定类。")]),a("li",[l._v("控制反转：spring通过控制反转的技术促进了松耦合，一个对象依赖的对象会通过被动的方式传递进去，而不是这个对象创建或者查询依赖对象。在容器中对象初始化后，就会将需要依赖的对象个创建完成。")]),a("li",[l._v("面向切面：允许通过分离服务中业务逻辑于系统级服务进行内聚性的开发，应用对象的只是完成自己该完成的，它们并不关注系统级，")]),a("li",[l._v("容器：spring管理者服务中所创建对象的生命周期，在这个意义上可以理解是一个容器，创建bean可以控制是单利对象还是一个每一次都创建一个新对象。")]),a("li",[l._v("框架：可以通过简单的组件配置，组合成一个负责的应用，支持声明式的组合，可以理解成在xml中编写，也提供了很多的基础功能，比如：事务，日志等。")])]),a("h3",[l._v("6.2、IOC，DI和AOP")]),a("ul",[a("li",[a("p",[l._v("IOC和DI：在spring中IOC就是负责创建对象，管理对象，装配对象，配置对象。并且管理这些对象的生命周期。")]),a("ul",[a("li",[a("p",[l._v("IOC和DI的组件可以把代码量降到最低，最小代价和最小侵入性使松散耦合实现。")]),a("p",[l._v("简单的来说就是IOC就是负责创建对象和管理对象，DI就是负责注入对象，在那个类中使用那个对象就把这个对象注入到需要地方。")])])])]),a("li",[a("p",[l._v("AOP就是一种面向切面编程的思想，目的就是将业务代码和公共的功能分离。")]),a("ul",[a("li",[l._v("aop的核心是切面，将多个类的通用方法封装成一个可以重用的模块，该模块提供了一组api提供给切面。")])])])]),a("h3",[l._v("6.3、spring常用的注入方式：")]),a("ul",[a("li",[l._v("构造方法注入。")]),a("li",[l._v("set方法注入。")]),a("li",[l._v("基于注解注入。")])]),a("h3",[l._v("6.4、spring的自动装配bean的方式：")]),a("p",[l._v("spring容器负责创建应用程序中bean，同时通过该ID来协调对象于对象之间关系。自动装配的方式如下:")]),a("ul",[a("li",[l._v("by name 根据bean的名字进行依赖注入。")]),a("li",[l._v("by type 根据bean的类型进行依赖注入。")]),a("li",[l._v("constructor 通过调用类的构造方法来进行注入。")]),a("li",[l._v("autodetect 容器首先通过构造方法来注入，发现失败，通过 autowired 来注入。")])]),a("h3",[l._v("6.5、spring中的java bean 是线程安全的吗：")]),a("ul",[a("li",[l._v("spring容器并没有提供线程安全的策略，所以spring 中java bean并不是线程安全的。")])]),a("h3",[l._v("6.6、spring中java bean的作用域：")]),a("ul",[a("li",[l._v("singleton：单例模式，表示该java bean在spring容器中只存在一个实例。")]),a("li",[l._v("prototype：原型模式，表示每一次通过getBean获取该实例时，都是一个新的实例。")]),a("li",[l._v("request：在每一个http时都会创建新的实例，只有在web中使用该作用域才会生效。")]),a("li",[l._v("session：在一个会话中，都会使用同一个实例，切换会话时，会新建一个实例，只有在web中使用才会生效。")]),a("li",[l._v("globalsession：每一个全局http session，仅在使用portlet context的时候有效。")])]),a("p",[l._v("比较常用的是单例模式和原型模式，对于单例模式作用域的bean在每次请求该bean都获取的是相同的实例，容器负责跟踪bean的状态，负责维护bean实例的生命周期。如果是原型模式的bean，程序在每一次请求该bean时，程序都会根据请求id创建一个新的实例，返回给程序，在这种情况下，spring容器仅仅使用new关键字来创建bean实例，一旦创建成功，容器就不负责实例的跟踪，也不会维护实例的生命周期。")]),a("h3",[l._v("6.7、spring中事务：")]),a("p",[l._v("在spring中的，支持两种类型事务：")]),a("ul",[a("li",[l._v("声明式事务： "),a("ul",[a("li",[l._v("就是业务代码和事务管理器分离，你只需要注解，xml配置的方式来管理事务。")]),a("li",[l._v("编程式事务管理，基于POJO的应用来说是为唯一选择。我们需要在代码中调用 开始事务，事务回滚，提交事务等方法。")]),a("li",[l._v("基于TransactionProxyFactioryBean的声明式事务管理。")]),a("li",[l._v("基于@Transactional的声明式事务管理。")]),a("li",[l._v("基于 切面 aop 配置事务。")])])]),a("li",[l._v("编程式事务： "),a("ul",[a("li",[l._v("通过手动编写事务管理，这样做灵活大，但是维护性较低。")])])])]),a("h3",[l._v("6.8、spring的事务隔离级别：")]),a("p",[l._v("事务隔离级别是指一个事务对数据操作于一个事务操作的隔离程度。当多个事务对同一个数据进行操作后，如果没有采用事务隔离级别处理的话，可能会出现一下的问题：")]),a("ul",[a("li",[l._v("脏读：一个事务读到了另一个事务还没有提交的数据。")]),a("li",[l._v("幻读：第一个事务对数据进行了修改，修改的数据是全部行时，第二个事务也要对数据修改，修改的是第一行数据，那么如果不隔离的话，就会发生，第一个事务修改过中，第二个事务修改了第一行数据，但是第一个事务会发现第一行的数据我修改了，怎么根我修改的不一致。")]),a("li",[l._v("不可重复读：对某些数据读取时，发现两次读取的数据居然不是一样的，也就是说没有读取到相同的内容，这是因为可能有其他事务对数据进行了修改。")])]),a("p",[l._v("事务隔离级别：")]),a("ul",[a("li",[l._v("read_uncommitted：读未提交，一个事务可以读取到另一个事务未提交的数据。")]),a("li",[l._v("read_committed：读已提交，一个事务只能读取到另一个事务提交的数据。")]),a("li",[l._v("repeatable_read：可重复读，一个事务可以多次访问数据库中同一条数据，而且多次读取的数据结果是一致的。")]),a("li",[l._v("serializble：序列化，是spring中最强的事务级别，事务在执行时，会在所以操作上都添加锁，比如：读，写操作都会添加锁，就相当于所有事务都是串行执行，但是这样做会造成性能下降。")]),a("li",[l._v("default：默认事务，可重复读。")])]),a("h3",[l._v("6.9、beanFactory和application context区别：")]),a("p",[l._v("bean factory和 application context都是接口")]),a("h3",[l._v("6.10、spring mvc的运行流程：")]),a("p",[a("img",{attrs:{src:i("ec9a"),alt:""}})]),a("ul",[a("li",[l._v("客户端向服务端发送请求，请求被spring前端控制servlet dispathchar servlet捕获。")]),a("li",[l._v("dispathchar servlet 会对请求的url进行解析，获取请求资源标识符，然后根据获取的资源标识符，调用handler mapping获取对应的handler配置的所有相关的对象，最后以 handler execution chain 对象的形式返回。")]),a("li",[l._v("获取handler，会选择一个合适的handler adapter。")]),a("li",[l._v("提取request中的模型数据，填充handler 入参，开始执行handler，填充handler的入参过程中，根据具体的配置，会做一下额外的工作。 "),a("ul",[a("li",[l._v("http message conveter 将请求消息转换成一个对象，将对象转换成指定的响应信息。")]),a("li",[l._v("数据转换：对请求消息进行数据转换，如string转换成integer等。")]),a("li",[l._v("数据根式化：对请求消息进行格式化，如果字符串或数字格式化成时间等。")]),a("li",[l._v("数据验证：验证数据的有效性，验证结果是否存储在binding result 或者 error中。")])])]),a("li",[l._v("handler执行完成后，向 dispathchar servlet返回一个model and view对象。")]),a("li",[l._v("根据返回的model and view选择合适的一个 view resolver返回给dispathchar servlet。")]),a("li",[l._v("view resolver 结合 model 和 view 来渲染视图。")]),a("li",[l._v("将渲染的视图返回给客户端。")])]),a("h3",[l._v("6.11、spring mvc中组件：")]),a("ul",[a("li",[l._v("dispathcharServlet：中央控制器，把请求转发到具体控制器类上。")]),a("li",[l._v("controller：具体处理请求的控制器。")]),a("li",[l._v("handler mapping：映射处理器，负责将中央控制器转发到controller上的映射策略。")]),a("li",[l._v("model and view：服务层返回数据和视图层的实体。")]),a("li",[l._v("view resolver：视图解析器，解析具体的视图。")]),a("li",[l._v("interceptors：拦截器，负责拦截我们定义好的请求，然后出处理工作。")])]),a("h2",[l._v("7、spring bot")]),a("h3",[l._v("7.1、什么是spring boot：")]),a("p",[l._v("springboot是一个框架，一种全新的变成规范，他们所产生简化了框架的使用，所谓简化操作是简化了spring中大量配置文件，所以在springboot是服务于一个框架的框架。服务范围是简化了配置文件。")]),a("ul",[a("li",[a("p",[l._v("springboot的优点：")]),a("ul",[a("li",[l._v("springboot 编码变得简单。")]),a("li",[l._v("springboot 的配置变得简单。")]),a("li",[l._v("springboot 部署变得简单。")]),a("li",[l._v("springboot 的监控变得简单。")])])]),a("li",[a("p",[l._v("springboot的核心配置文件：")]),a("ul",[a("li",[l._v("properites文件。")]),a("li",[l._v("yaml文件。")])]),a("p",[l._v("这两个格式的配置文件，都可以配置springboot应用，但是yaml配置起来比较舒服，看着比较简洁，但是有很严格的层级格式，如果层级格式发生变化，整个配置都会出现问题。properiter配置会比较冗余，但是配置更新起来不容易出现错误。")])])]),a("h3",[l._v("7.2、java config：")]),a("p",[l._v("简单的来说，就是解决了spring大量的配置文件的问题，使用java代码来配置很多对象。")]),a("ul",[a("li",[l._v("使用该对象，可以直接注入在容器中，使用@bean注解，可以直接将对象注入到容器中。")])]),a("h3",[l._v("7.3、spring boot中监视器：")]),a("p",[l._v("是spring boot中一个重要组件，spring boot actuator，可以监视 当前应用的状态。比如：bean 的列表，配置信息，内存消耗等。")]),a("h3",[l._v("7.4、springboot中核心注解：")]),a("p",[l._v("启动类上的注解："),a("code",{pre:!0},[l._v("@SpringBootApplication")]),l._v("它是springboot的核心组件，用来表示该应用是一个springboot的项目，它里面包含了是三个注解：")]),a("ul",[a("li",[a("code",{pre:!0},[l._v("@SpringBootConfiguration")]),l._v("：组合了"),a("code",{pre:!0},[l._v("@Configuration")]),l._v("注解，实现了配置文件的功能。")]),a("li",[a("code",{pre:!0},[l._v("@EnableAutoConfiguration")]),l._v("：打开了自动配置的功能，也可以关闭某一个自动配置的选项，比如关闭数据库的连接。")]),a("li",[a("code",{pre:!0},[l._v("@ComponentScan")]),l._v("：spring组件扫描，复杂扫描应用中的spring组件。")])]),a("p",[a("img",{attrs:{src:i("561e"),alt:""}})]),a("h3",[l._v("7.5、springboot自动配置原理：")]),a("p",[l._v("Springboot的自动配置是通过"),a("code",{pre:!0},[l._v("@EnableAutoConfiguration")]),l._v("开启自动配置，开启后，会对"),a("code",{pre:!0},[l._v("jar")]),l._v("包下"),a("code",{pre:!0},[l._v("spring.factories")]),l._v("文件进行扫描，这个文件里面包含了自动配置的类，当满足了"),a("code",{pre:!0},[l._v("@Condition")]),l._v("注解指定的条件后，并在依赖的支持下，实例化，并注册到spring容器中。")]),a("h4",[l._v("7.5.1、springboot核心配置原理：")]),a("ul",[a("li",[l._v("自动配置的类存放在"),a("code",{pre:!0},[l._v("spring-boot-autoconfiguration-veriosn.jar")]),l._v("下的"),a("code",{pre:!0},[l._v("org.springframework.boot.autoconfiguation")]),l._v("中。")]),a("li",[l._v("当我们在"),a("code",{pre:!0},[l._v("application.properties")]),l._v("中配置了debug=true后启动容器，可以看到服务初始化时的初始化配置。")]),a("li",[a("code",{pre:!0},[l._v("DispathcharServletAutoConfiguration")]),l._v("注册前端控制器。")]),a("li",[a("code",{pre:!0},[l._v("EmdeddedServletContainerAutoConfiguration")]),l._v("注册容器类型。")]),a("li",[a("code",{pre:!0},[l._v("HttpMessageConvertersAutoConfigguration")]),l._v("注册JSON或XML处理器。")]),a("li",[a("code",{pre:!0},[l._v("JacksonAutoConfiguration")]),l._v("注册json对象解析器。")]),a("li",[l._v("如果加入了其他功能的依赖，springboot还会实现这个功能的自动配置。")])]),a("p",[a("img",{attrs:{src:i("b76c"),alt:""}})]),a("h4",[l._v("7.5.2、starter组件：")]),a("p",[l._v("starter组件时可以被加载在应用中的maven依赖，只有在maven配置中配置对应的依赖，可以使用对应的starter组件，如：添加spring-boot-starter-web依赖，就可以用来构建rest api服务。")]),a("p",[l._v("一个完整的starter组件包含以下两个特点：")]),a("ul",[a("li",[l._v("提供自动配置的功能自动配置模块。")]),a("li",[l._v("提供依赖关系管理岗的组件模块，即封装了组件的所有功能，开箱即用。")])]),a("h4",[l._v("7.5.3、三大注解：")]),a("ul",[a("li",[a("code",{pre:!0},[l._v("@SpringBotConfiguration")]),l._v("：基础"),a("code",{pre:!0},[l._v("@Configuration")]),l._v("，支持java config的方式进行配置。")]),a("li",[a("code",{pre:!0},[l._v("@EnableAutoConfiguration")]),l._v("：主要用来开启自动配置。")]),a("li",[a("code",{pre:!0},[l._v("@ComponentScan")]),l._v("：自动组件扫描，默认扫描该类所在以及子包下所有的带有指定的注解的类，将它们自动配置到bean容器中，会被自动装配的注解包括："),a("code",{pre:!0},[l._v("@Controller")]),l._v("，"),a("code",{pre:!0},[l._v("@Service")]),l._v("等、、、")])]),a("h4",[l._v("7.5.4、@EnableAutoConfiguration：")]),a("p",[l._v("这个注解时帮助springboot的自动配置的核心，它里面有两个关键的注解@AutoConfigurationPackage和@import。")]),a("ul",[a("li",[l._v("@Import(AutoConfigurationImportSelector.class)：该注解的核心是AutoConfigurationImportSelector这个类，这个类中有一个非常重要的方法"),a("code",{pre:!0},[l._v("selectImport")]),l._v("方法，它几乎覆盖了所以自动装配的处理逻辑，包括获取候选配置类，配置类去重，排除不需要的类，过滤等操作，最后返回符合条件的自动配置的类的全限定名。")])]),a("h4",[l._v("7.5.5、springFactoriesLoader：")]),a("p",[l._v("spring-core包里面定义了springFactoriesLoader类，这个类实现了检索MEIA-INF/spring.factories文件，并获取指定接口的配置的功能。这个类定义了两个对外的方法：")]),a("ul",[a("li",[l._v("loadFactories 根据接口类获取对应的实现类。这个方法返回的是对象列表。")]),a("li",[l._v("loadFactoryName 根据接口获取接口类的名称，这个方法返回的是类名的列表。")])]),a("p",[l._v("这个类中方法会把spring.factories文件中所以配置的类。")]),a("h2",[l._v("8、spring cloud")]),a("h3",[l._v("8.1、spring cloud常见组件")]),a("p",[l._v("springcloud是一个分布式系统系统，云服务框架，可以快速的构建一个分布式系统。里面包含了一些常见的组件。")]),a("ul",[a("li",[l._v("配置管理。")]),a("li",[l._v("服务注册与发现。")]),a("li",[l._v("断路器。")]),a("li",[l._v("智能路由。")]),a("li",[l._v("服务间的调用。")]),a("li",[l._v("负载均衡。")]),a("li",[l._v("微服务。")]),a("li",[l._v("控制总线。")])]),a("h3",[l._v("8.2、spring cloud 的核心组件有哪些：")]),a("ul",[a("li",[l._v("服务发现：eureka服务器作为服务注册服务。eureka客户端是一个java客户端，用来简化于服务端的交互，作为负载器，并支持服务的故障切换，")]),a("li",[l._v("负载均衡：Ribbon 主要是提供了负载均衡的算法，比如链接超时，重试，重试算法等。")]),a("li",[l._v("断路器：hystrix可以防止一个应用程序在多次尝试执行一个操作，如果这个操作执行失败了，可能会需要等待一定的时间才能恢复，但是不能一直尝试，如果一直尝试会浪费资源，可以快速响应。等待操作恢复后，就可以正常访问。")]),a("li",[l._v("网关：zuul，类似于的nigx，具有反向代理的作用，统一路由。")]),a("li",[l._v("统一配置：可以将所有的服务配置信息，放在统一配置中。")])]),a("h3",[l._v("8.3、服务注册和服务发现是什么，spring cloud是如何实现的：")]),a("p",[l._v("在开发中，会发现服务越来越多，管理这些服务越来越麻烦，服务也有可能会变化。而服务注册就是，将这些服务统一注册到一个平台中，对所有的服务进行统一管理，服务发现，就是在调用这些服务的时候，不需要的知道具体服务器地址，可以安装服务名称去调用服务的api，这样可以避免服务地址变了，服务的调用方也需要跟着发生变化。")]),a("p",[l._v("在spring cloud中，使用的eureka来做为服务的注册中心的，服务启动时，就会向eureka注册，当服务调用是，根据服务名称去eureka中查询服务信息，在进行调用，调用服务不需要提前知道需要调用的服务地址。")]),a("h3",[l._v("8.4、什么是hystrix：")]),a("p",[l._v("hystrix是一个延时和容错库，在隔离远程系统，服务和第三方的访问点，当出现不可避免的故障时，停止连级故障时并在分布式系统中弹性扩容。")]),a("p",[l._v("通常在微服务系统中，服务与服务之间的调用时，如果某一个服务出现调用失败，会导致出现失败服务的前面服务出现一系列的失败，而hystrix就是在失败时，返回一个特定值，进行服务的熔断，避免服务出现一系列的失败，")]),a("p",[l._v("hystrix的功能概述：")]),a("ul",[a("li",[l._v("资源隔离：限制了分布式服务的资源使用，某一个调用服务出现问题的时候，不会影响到其它服务的调用。")]),a("li",[l._v("限流机制：主要针对提前设置了访问次数的QPS阈值的接口，当达到限制阈值时，该请求将直接返回，不会调用后面的资源。")]),a("li",[l._v("熔断机制：当服务的失败次数达到阈值时，会自动触发熔断，熔断是快速失败，告诉调用者当前服务处于不可用的状态，或者直接给出提前定义好返回值。")]),a("li",[l._v("降级机制：当服务超时降级，资源不足，运行异常时，服务会自动降级，返回提前定义好返回值。")]),a("li",[l._v("缓存支持：提供了请求缓存，请求合并实现。")]),a("li",[l._v("监控报警：通过近实时的监控，统计，报警功能，来提高故障发现的速度。")]),a("li",[l._v("热部署：通过近实时的属性和配置功热修改来实现，来提高故障后的处理和恢复的速度。")])]),a("h4",[l._v("8.4.1、hystrix熔断原理：")]),a("ul",[a("li",[l._v("熔断请求的判断机制算法：使用无锁循环队列计数，每一个熔断器维护10个bucket，每一个请求一个bucket，每一个bucket记录这个请求的成功，失败，超时，拒绝等状态，默认超过50%且10秒超过20个请求会进行拦截。")]),a("li",[l._v("熔断恢复：对于被熔断的请求，每隔5秒会允许部分请求通过，若请求都是健康的，则关闭熔断。")]),a("li",[l._v("熔断报警：对于熔断的请求打日志，异常请求超过某些设定则报警。")])]),a("h4",[l._v("8.4.2、hystrix隔离设计：")]),a("ul",[a("li",[l._v("线程隔离模式：使用一个线程池来存储当前的请求，线程池对请求做处理，设计任务返回处理超时时间，堆积的请求堆积入线程池队列。这种方式需要为每个依赖的服务申请线程池，有一定的资源消耗，好处是可以应对突发流量（流量洪峰来临时，处理不完可将数据存储到线程池队里慢慢处理）。")]),a("li",[l._v("信号量隔离模式：使用一个原子计数器来记录当前有多少个线程在运行，请求到达前，先判断当前计数器的数值，如果当前计数器的值大于设置的最大的线程数时，就放弃的该请求，如果不超过，请求来时，计数器+1，请求响应结束 时，计数器-1、这中模式不能限制突发的流量（流量洪峰时，处理的线程超过），")])]),a("h4",[l._v("8.4.3、hystrix的超时机制设计：")]),a("ul",[a("li",[l._v("等待超时：在任务入队列时，记录任务入队时间，并判断队头的任务是否超过了最大超时时间，超过则丢掉任务。")]),a("li",[l._v("运行超时：直接可以使用线程池提供get方法。")])]),a("h3",[l._v("8.5、OpenFeign：")]),a("ul",[a("li",[l._v("在使用OpenFeign时，需要在启动类上添加EnableFeignClients注解，该注解会导入FeignClientsRegistrar类，会去扫描所有带@FeignClient的接口。")]),a("li",[l._v("解析到@FeignClient修改的接口后，Feign框架通过扩展 spring bean deifinition的注册逻辑，最终注册一个 feign client facotory bean进行spring容器中。")]),a("li",[l._v("spring容器在初始化用到的Feignclient接口的时候，获得的是FeignClientFacotoryBean产生一个代理对象proxy。")]),a("li",[l._v("基于java原生的动态代理机制，针对proxy的调用，都会被统一转发给Feign框架所定义的一个InvocationHandler，有该handler完成后续Http的转换，发送，接受，翻译Http响应的工作。")])]),a("h2",[l._v("9、MyBatis")]),a("h3",[l._v("9.1、什么是MyBatis：")]),a("p",[l._v("是一个半ORM框架（ORM：对象关系映射），它内部封装联JDBC的操作，在开发时只需要开发sql语句就可以了，对于数据驱动，数据库链接，创建数据库对象等操作就不需要在重复操作，mybatis已经集成了。")]),a("p",[l._v("使用xml文件或注解的方式来配置和映射数据操作和结果集，不需要在手动编写结果映射。")]),a("h3",[l._v("9.1、#{} 和 ${}的区别：")]),a("ul",[a("li",[l._v("#{}预编译的处理， ${}直接是字符串替换。${}使用尽量避免，容易造成sql注入风险。#{}会将变量替换成？，不是直接字符拼接在sql上。")])]),a("h3",[l._v("9.2、mybatis的一级和二级缓存：")]),a("ul",[a("li",[l._v("一级缓存：一级缓存是作用在 sql session上，如果这个session失效了，缓存也就失效了，一级缓存是本地缓存，是属于默认开启。一级缓存是基于perpetual cache的hashmap的本地缓存。在这个session执行commit，插入，删除，更新操作时，缓存就会失效。另外二级缓存也会失效。")]),a("li",[l._v("二级换成是sql session factory对象的缓存，有用一个sql session factory创建sql session共享其缓存。二级缓存其实基于mapper的缓存，在关闭sql session时，才会把sql session中一级缓存中数据放在二级换成中，开始二级缓存是，需要主要 pojo实例需要被序列化，因为二级缓存中数据较大，存储的数据介子多种多样，所以一定是存在内存中，也有可能是存在硬盘中的。二级缓存是有过期时间，默认是一个小时，有flush intervel去检测缓存数据。")]),a("li",[l._v("在数据查询时，会先查询二级缓存，在查询一级缓存，如果都没有，最后才会查询数据库。")])]),a("h3",[l._v("9.3、mybatis的mapper的工作原理：")]),a("p",[l._v("在mybatis中，mapper就是来负责于数据库进行交互的，根据接口的全限定名最为一个mapper文件的namespace的值，接口中方法名，就是mapper文件中的mapped statement的唯一ID值，接口内方法参数的就是sql的参数，在实现时mapper没有实现类，当调用接口方法时，就使用的是全限定名 + 方法名，定位唯一的mapped statement。")]),a("p",[l._v("mapper的工作原理就是JDK的动态代理，mybatis在运行时，会使用的JDK的动态代理为mapper的接口生成proxy对象，代理对象会拦截接口方法，转而执行mapper statement的sql，然后在将结果返回。")]),a("h2",[l._v("10、mysql")]),a("h3",[l._v("10.1、事务隔离级别：")]),a("ul",[a("li",[l._v("read uncommited：读未提交，就是说一个事务可以读取到另一个事务未提交的数据。容易引起脏读。")]),a("li",[l._v("read commited：读已提交，就是一个事务只能读取到另一个事务已经提交的数据。容易引起幻读。")]),a("li",[l._v("repeatable：可重复读，表示每一次读取的数据都是一样的。")]),a("li",[l._v("serializable：串行事务，级别最高的事务。在所有操作上都会添加锁，读写都会添加，效率较低。")])]),a("h3",[l._v("10.2、char 和 varchar的区别：")]),a("ul",[a("li",[l._v("char：固定长度的字符串，默认是255的长度，在存储时，如果数据没有占用255的长度，消耗的存储空间也是255。")]),a("li",[l._v("varchar：可变化长度字符串，默认长度也是255，在存储时，会根据实际字符串的长度存储，消耗的是实际存储的空间。")])]),a("h3",[l._v("10.3、mysql数据库服务器性能分析的操作：")]),a("ul",[a("li",[l._v("show status：获取一些监控变量值，可以查询服务运行时间，select，update等操作次数，缓存内的线程数，打开的链接数等。")])]),a("h3",[l._v("10.4、blob 和 text：")]),a("ul",[a("li",[l._v("blob：是存储一个二进制对象。")]),a("li",[l._v("text：其实本质上是一个不区分大小写的blob。一般用来存储大字符串。")])]),a("h3",[l._v("10.5、数据库三范式：")]),a("ul",[a("li",[l._v("第一范式：一张表中的字段是不可在分割的，所有的域都是具有原子性。")]),a("li",[l._v("第二范式：在满足第一范式后，表中每一条记录都必须可以被唯一区分。")]),a("li",[l._v("第三范式：在慢足第一和第二范式后，要求表中的每一条数据要于主键直接相关，不能间接相关。消除依赖传递。")])]),a("h3",[l._v("10.6、mysql中的函数：")]),a("ul",[a("li",[l._v("abs：求绝对值的函数。")]),a("li",[l._v("floor：向下取整。")]),a("li",[l._v("ceil：向上取整。")]),a("li",[l._v("now：获取当前时间。")]),a("li",[l._v("adddate(date, num)：在date上加上num天的时间。")]),a("li",[l._v("subdate(date，num)：在date上减去num天的时间。")]),a("li",[l._v("sum：求和。")]),a("li",[l._v("avg：求平均值。")]),a("li",[l._v("count：求总数。")]),a("li",[l._v("max：求最大值。")]),a("li",[l._v("min：求最小值。")])]),a("h3",[l._v("10.7、mysql中的锁：")]),a("ul",[a("li",[l._v("myISAM：支持表锁。")]),a("li",[l._v("innoDB：支持表锁，行锁。默认行锁。")]),a("li",[l._v("表锁：开销小，加锁快，不会出现死锁，锁的颗粒度较大，容易引起锁冲突。并发较低。")]),a("li",[l._v("行锁：开销大，加锁慢，容易出现死锁，锁的颗粒度较小，发生锁冲突较小，并发较高。")])]),a("h3",[l._v("10.8、mysql数据优化：")]),a("ul",[a("li",[l._v("优化数据类型： "),a("ul",[a("li",[l._v("避免使用null，null需要特殊处理，大多数应该使用not null的情况，或者为null的情况使用一些特殊值表示。")]),a("li",[l._v("尽量使用更小的字段来存储，比如 char 和 varchar字段，因为从磁盘读取数据到内存中的，然后使用cpu周期和磁盘IO读取数据，这就意味着数据越小，占用的空间越小，速度也越快。")])])]),a("li",[l._v("数据类型正确使用： "),a("ul",[a("li",[l._v("客户端或应用端使用的字符集可能于本身的字符集不一致，这时就需要mysql在运行的时候进行转换。")])])]),a("li",[l._v("优化 select * 和 count(*) 这样的操作。")]),a("li",[l._v("优化子查询： "),a("ul",[a("li",[l._v("在子查询时，mysql查询优化引擎并不是最有效的，这就是为啥经常把子查询转换连接查询的原因，优化器可以正确的处理连接查询，注意的一点是，确保连接表的连接列存在索引。在第一张表上通常会相当于对第二张的查询子集上做一次全表扫描，这是嵌套循环算法的一部分。")])])]),a("li",[l._v("优化union: "),a("ul",[a("li",[l._v("在跨多个不同的数据时，union是一个有趣的优化方法，union从两个互不关联的表中返回数据，这就意味着不会出现重复的行，同事也要对数据进行排序，排序是非常耗时，如果表越大，消耗的时间就越大。")]),a("li",[l._v("union all 可以加速，但是你要保证你的数据中不会出现重复数据和重复行，这两种情况下使用union all 更合适，union all 不会对数据进行排序。")])])])]),a("h3",[l._v("10.9、mysql存储引擎：")]),a("ul",[a("li",[a("p",[l._v("myisam：这种引擎是mysql最早提供的，可以分为三类：静态，动态，压缩。")]),a("ul",[a("li",[l._v("静态：如果数据库表的数据的长度都是预先固定好了的，服务器将自动选择这种类型。因为每一条数据的大小是一样的，他它们所占用的空间也是一样的，所以这种表的存储和获取的效率是很高的，数据恢复起来也是比较方便的。")]),a("li",[l._v("动态：如果说数据库表的出现了 varchar ，text 或者 blob字段时，服务器会自动选择这种类型，这种类型的存储相对于静态来说，存储空间占用较小，但是每一条记录的大小是不一样的，所以多次修改后，数据表中的数据可能会离散在存储的内存中，进而导致执行系效率降低，同时，内存中也会出现存储碎片，所以这种类型存需要使用optimize table命令来整理内存中碎片。")]),a("li",[l._v("压缩：这种类型会对表进一步压缩，所占用的空间会更小，但是这种存储类型一旦存储了就不能在修改了，另外，在获取数据是，也需要对数据解压。")])]),a("p",[l._v("不管myisam任何类型，都是不支持事务的，行级锁，外键约束。")])]),a("li",[a("p",[l._v("myisam merge 引擎：这就是在 myisam类型的一个变种，就是将几个相同myisam中相同的表合并成一个虚表，常用于日志和数据仓库。")])]),a("li",[a("p",[l._v("inno db：可以看成是 myisam 的更新产品，它提供了事务，行级锁，外键约束功能。")])]),a("li",[a("p",[l._v("memory（heap）：这种类型的表，会存在内存中，使用的散列表，所以他的存储速度是很快的，因为是存在内存中，通常用来作为临时表。")])])]),a("p",[l._v("注意：如果在MySQL中插入18条数据，id采用的是自增主键，此时ID已经等于18，如果删除ID为15,16,17,18的数据，如果现在重启MySQL服务，在插入一条数据，那么这条数据的ID是多少？？？")]),a("ul",[a("li",[l._v("如果表的存储引擎是Myisam类型话，那么ID是19，因为myisam引擎会记录最大ID在文件中，所以重启后还是知道最大ID是多少。")]),a("li",[l._v("如果表的存储引擎是Innodb类型话，那么ID是17，因为Innodb引擎是把最大ID记录在内存中，重启后就已经丢失了。")])]),a("h3",[l._v("10.10、truncate，delete，drop的区别：")]),a("ul",[a("li",[l._v("drop：是不可逆的，会将所占用的空间全部释放。")]),a("li",[l._v("truncate：只针对于表的删除操作，在删除表的过程中，不会激活于表相关的删除触发器，并且不会把删除记录放在日志中，当表被删除后，这个表和索引会恢复到初始大小。")]),a("li",[l._v("delete：可以删除表也可以删除行，但是删除记录会被保存在日志的，而且表也会不恢复到原来的大小。")])]),a("h3",[l._v("10.11、事务的特征：")]),a("p",[l._v("事务具有四个特征：原子性，一致性，隔离性，持久性。")]),a("ul",[a("li",[l._v("原子性：事务必须是一个原子序列单元，简单的来说，就是一个事务中，包含多个操作时，要保证多个操作成功，其中有一个操作失败，那么整个事务都失败，只有所以操作都成功了，整个事务才成功。")]),a("li",[l._v("一致性：事务不能破坏数据库的数据的完整性和一致性，就是说，在执行一个事务的前后，数据库都必须处于一致性的状态。")]),a("li",[l._v("隔离性：在并发中，每一个事务都是独立的，一个事务不能影响到另一个事务。")]),a("li",[l._v("持久性：在事务提交后，数据库操作的数据必须要保持不变，在没有修改数据情况下，数据不能发生任何变化。")])]),a("h3",[l._v("10.12、MySQL咋来实现事务：")]),a("p",[l._v("mysql中以innodb来解释：innodb是通过锁和日志来保证事务ACID的。")]),a("ul",[a("li",[l._v("通过数据库锁的机制来实现事务隔离性。")]),a("li",[l._v("通过重做日志来实现事务持久性。")]),a("li",[l._v("通过撤销日志来实现事务的一致性和原子性。")])]),a("h2",[l._v("11、Kafka")]),a("h3",[l._v("11.0、原理：")]),a("h4",[l._v("11.0.1、Topic")]),a("p",[l._v("Kafka学习了数据库里面的设计，在里面设计了topic（主题），这个类似于关系型数据库的表。")]),a("p",[a("img",{attrs:{src:i("5c34"),alt:""}})]),a("h4",[l._v("11.0.2、Partition 分区")]),a("ul",[a("li",[l._v("kafka里面有一个概念叫 partition 分区，分区具体在服务器上面表现期初就是一个目录。")]),a("li",[l._v("一个topic里面可以有很多个分区，这些分区会存储在不同服务器上。这些分区的主要信息存储在.log文件里面，")])]),a("p",[a("img",{attrs:{src:i("c90f"),alt:""}})]),a("p",[l._v("为了提高性能，多个分区可以使用多线程来处理消息，kafka里面topic是逻辑概念，分区就是分布式存储单元。")]),a("ul",[a("li",[l._v("分区会有单点故障，所以一般都会给分区设置数据备份。")]),a("li",[l._v("分区编号是从0开始的。")])]),a("h4",[l._v("11.0.3、Producer 生产者")]),a("p",[l._v("producer就是负责生成消息，把消息push到kafka服务中。")]),a("p",[a("img",{attrs:{src:i("e1bc"),alt:""}})]),a("h4",[l._v("11.0.4、Consumer 消费者")]),a("p",[l._v("就是从kafka服务里面获取数据。")]),a("p",[a("img",{attrs:{src:i("9492"),alt:""}})]),a("h4",[l._v("11.0.5、Message 消息")]),a("p",[l._v("在kafka里面的一条数据就是叫一条消息。")]),a("h4",[l._v("11.0.6、Kafka集群")]),a("p",[l._v("创建一个topic a 的主题，3个分区分别存储在不同服务器上面，也就是broker下面。")]),a("p",[l._v("topic是一个逻辑概念，并不能直接在图中把topic的相关单元画出来：")]),a("p",[a("img",{attrs:{src:i("bfeb"),alt:""}})]),a("p",[l._v("需要注意：kafka在0.8之前，是没有副本复制机制的，所以在使用的时候，需要注意kafka版本。")]),a("h4",[l._v("11.0.7、Replica 副本")]),a("p",[l._v("在kafka中partition分区为了保证数据安全，所以每一个partition可以设置多个副本集。")]),a("p",[l._v("此时我们多分区 0,1,2分别设置了3个副本（其实设置2个副本就可以了）")]),a("p",[a("img",{attrs:{src:i("ae07"),alt:""}})]),a("p",[l._v("其实每一个副本之间都有角色的区分，他们会选取一个副本作为 leader，而其余的作为 follower。")]),a("p",[a("strong",[l._v("在集群环境下发布消息")])]),a("p",[l._v("生产者在发送数据的时候，是直接发送到leader partition（主分区）里面，然后 follower partition会去leader那里自行同步数据，消息者在消息数据时，也会去leader partition中去拉取数据。")]),a("p",[a("img",{attrs:{src:i("c6dd"),alt:""}})]),a("h4",[l._v("11.0.8、消费组")]),a("p",[l._v("在消费者代码里面指定一个group.id，这个id名字代表消费组的名字，如果不设置group.id这个名字，系统也会默认设置一个消费组。")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-java"}},[l._v("conf.setProperty("),a("span",{pre:!0,attrs:{class:"hljs-string"}},[l._v('"group.id"')]),l._v(", "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[l._v('"tellYourDream"')]),l._v(")\n")])]),a("p",[l._v("消费组内任意一个消费者去消费了消息A后，该消费组内的其他消费者就不能在去消费该条消息了。但是如果两个消费者在不同的消费组里，这样的情况下，两个消费者都可以消费到同一条消息。所以消费组是并行的去消费消费的，多个消费者并不会消费到同一条消息。")]),a("p",[a("img",{attrs:{src:i("fba3"),alt:""}})]),a("p",[l._v("如图：前面提到过，消息者会去连接leader消费数据，所以消费组内，会去连接多个broker里面leader，所以一个分区不会让一个消息组内的消息者去消费同一条消息，但是在消息者不饱和的情况下，一个消费者可以消费多个分区内的数据。")]),a("h4",[l._v("11.0.9、controller")]),a("p",[l._v("在大多数分布式系统中，95%都是采用主从架构，个别的采用是对等式架构，比如：es。")]),a("p",[l._v("kafka采用的也是主从架构，主节点被称为controller，其余的称为从节点，controller需要和zookeeper进行配合管理整个集群，")]),a("h4",[l._v("11.0.10、kafka和zookeeper")]),a("p",[l._v("kafka集群是严重依赖于zookeeper的，集群中所有的broker启动的时候，都会向zookeeper注册，目的是选举出一个controller。这个选举过程很简单粗暴，就是第一个broker先注册就是那个broker当controller。不涉及到什么算法问题。")]),a("p",[l._v("成为conroller后，需要监听zookeeper里面的多个目录，比如controller节点一个brokers目录，其他从节点就会往这个节点上注册，一般命名规则是0,1,2....就是各个broker的id编号，在注册时，必须暴露自己主机IP端口等信息。")]),a("p",[l._v("此时controller节点就需要监听注册上来从节点信息，生成集群元数据休息，然后在将这些元数据信息分发到其他机器上，这个整个集群环境中的broker就知道了集群信息，")]),a("h4",[l._v("11.0.11kafka性能好的地方")]),a("ul",[a("li",[a("p",[l._v("顺序写：")]),a("p",[l._v("在kafka中，数据就是存储在磁盘上的，一般来说，数据存储在内存中，效率会更高。但是kafka用的是顺序写，追加到数据末尾，磁盘顺序写的效果比较高。")])]),a("li",[a("p",[l._v("零拷贝：")]),a("p",[l._v("这是非零拷贝的情况：")]),a("p",[a("img",{attrs:{src:i("88e1"),alt:""}})])]),a("li")]),a("h3",[l._v("11.1、kafka的数据清理机制：")]),a("p",[l._v("kafka存在两个消息清理机制：")]),a("ul",[a("li",[l._v("按照过期时间清理消息。")]),a("li",[l._v("按照消息大小清理消息。")])]),a("p",[l._v("如果设置了10天过期，数据量达到10G后清除数据，如果在第11天，数据没有满足10G，或者在第九天，数据满足10G，kafka会怎么办？？？这个时候kafka都会执行清除数据任务，时间和大小无论是那么一个满足了，都会执行清理数据。")]),a("h3",[l._v("11.2、搭建kafka集群需要注意什么：")]),a("ul",[a("li",[l._v("集群不是越多越好，如果集群太多了，会导致主从数据同步时，消耗的时间越长，就会降低整个集群的吞吐量，一般集群控制在7个左右就好了。")]),a("li",[l._v("一般集群数量保证为单数，因为kafka不会判断集群是否可用，是集群过半的服务宕机后，集群就不可用了，设置成单数容错比较高。")])]),a("h3",[l._v("11.3、kafka如何保证消息丢失：")]),a("p",[l._v("生产者：")]),a("ul",[a("li",[l._v("防止消息丢失在kafka里面采用了ack机制。ack存在三个参数，可以防止消息丢失。 "),a("ul",[a("li",[l._v("0：producer不等待broker的ack，也就是说，producer生产一条消息后，就发送到broker就返回，不管broker存成功了没有。")]),a("li",[l._v("1：producer发送消息到broker的主分区上，就返回了，不会等待主分区的消息复制到副分区上，如果刚刚发送到主分区上就宕机了，该消息就丢失了，所以，这样也存在消息丢失的问题。")]),a("li",[l._v("-1：producer发送消息到broker的主分区上，也等待主分区上的数据复制到副分区上后，此时才broker返回ack。")])])])]),a("p",[l._v("消费端：")]),a("ul",[a("li",[l._v("关闭自动提交也可以。")])]),a("h3",[l._v("11.4、防止重复消费：")]),a("p",[l._v("解决方案：")]),a("ul",[a("li",[l._v("基于幂等性，将消费的消息id存储起来，每次消费的时候，先去判断是否已经被消费过。")]),a("li",[l._v("基于缓存，将消费的消息id先缓存下来，每次消费的时候，先去判断是否已经被消费过。")])]),a("h2",[l._v("12、redis")]),a("h3",[l._v("12.1、什么是redis，有那些应用场景：")]),a("p",[l._v("redis是一个开源的内存数据库，存储key-value数据库，提供了持久化机制。使用场景：")]),a("ul",[a("li",[l._v("数据高并发的读写。")]),a("li",[l._v("海量数据的读写。")]),a("li",[l._v("对扩展性要求高的数据。")])]),a("h3",[l._v("12.2、redis和memecahe有什么区别：")]),a("ul",[a("li",[l._v("redis：支持持久化，速度快，支持做种数据类型。")]),a("li",[l._v("memecahe：不支持持久化，相对于redis速度慢，只支持字符串类型。")])]),a("h3",[l._v("12.3、redis为啥是单线程：")]),a("p",[l._v("因为Redis是内存数据库，所有数据是放在内存中的，所以影响redis性能的是内存大小和网络带宽，cpu并不是性能瓶颈，单线程的实现比较加单，所以就才用来单线程。")]),a("h3",[l._v("12.4、什么是缓存穿透：")]),a("ul",[a("li",[l._v("缓存穿透：就是查询一个数据库不存在的数据，由于数据不存在，所以缓存不会命中，就会查询数据库，但是数据库也没有，所以就不会将结果放入缓存中，这样就导致每一个请求时，都会直接访问数据库。")]),a("li",[l._v("解决方案：将查询为空的结果也放入缓存中，但是可以设置一个较短的过期时间。")])]),a("h3",[l._v("12.5、什么是缓存雪崩：")]),a("ul",[a("li",[l._v("缓存雪崩：就是缓存中的缓存大量的失效了，这样就导致所有的请求全部都访问的到数据库上了。")]),a("li",[l._v("解决方案：将缓存中的数据设置不同的过期时间，避免大部分缓存在同一时间过期失效。")])]),a("h3",[l._v("12.6、什么是缓存击穿：")]),a("ul",[a("li",[l._v("缓存击穿：于缓存雪崩类似，只是一个热key过期了，大量的并发一下就全部到了数据库。")]),a("li",[l._v("解决方案： "),a("ul",[a("li",[l._v("热点数据设置较长的过期时间，或者通过计算热key，自动更新过期时间。")]),a("li",[l._v("使用互斥锁，如果大量请求时，让一个请求先去完成数据库查询，在放入缓存，这样后面的请求就去缓存中查询。")])])])]),a("h3",[l._v("12.7、如何保证缓存和数据库一致：")]),a("ul",[a("li",[l._v("合理的设置过期时间。")]),a("li",[l._v("在新增，删除，修改的操作时，就同步更新redis缓存，可以利用事务机制来保证数据的一致。")])]),a("h3",[l._v("12.8、redis淘汰策略：")]),a("ul",[a("li",[l._v("volatie-lru：从已设置过期时间中挑选最近使用最少使用的数据。")]),a("li",[l._v("volatie-random：从已设置过期时间中随机挑选即将过期的数据。")]),a("li",[l._v("allkeys-lru：从整个数据集中挑选使用最少的数据。")]),a("li",[l._v("allkeys-random：从整个数据集中随机挑选数据。")]),a("li",[l._v("no-enviction：禁止驱逐数据。")])]),a("h2",[l._v("13、es")]),a("h3",[l._v("13.1、倒排索引：")]),a("p",[l._v("传统的索引是通过文章，逐个遍历查询对应的文章关键词。")]),a("p",[l._v("倒排索引是通过分词策略，形成词于文章之间的关系，也称为倒排表，这种词典+映射表为倒排索引。")]),a("p",[l._v("其中词典中存储就是词元，倒排表中存储的就是该词元在那个文章位置上出现过。")]),a("p",[l._v("有了倒排索引，就能实现o(1)时间复杂度的效率索引文章，极大的提高了检索的效率。")]),a("p",[l._v("倒排索引的底层的基于 FST的数据结构。")]),a("p",[l._v("FST的数据结构的优点：")]),a("ul",[a("li",[l._v("空间占用比较小，通过对词典中单词前缀和后缀的重复利用，压缩了存储空间。")]),a("li",[l._v("查询速度快。")])]),a("h3",[l._v("13.2、如何实现master选举：")]),a("p",[l._v("前置条件：")]),a("ul",[a("li",[l._v("只有候选节点才能成为主节点。")]),a("li",[l._v("最小主节点数的目的是防止产生脑裂。")])]),a("p",[l._v("ES的选举是靠zenDiscovery模块负责的，主要包含ping和unicast这个两部份。")]),a("ul",[a("li",[l._v("ping：节点与节点之间使用RPC来发现彼此。")]),a("li",[l._v("unicast：单播模块，里面包含一个主节点列表以控制那些节点需要ping通。")])]),a("p",[l._v("获取主节点的核心是findMaster方法，获取成功返回对应master，失败就返回null。")]),a("p",[l._v("选举的大致流程：")]),a("ul",[a("li",[a("p",[l._v("确定候选节点数量达标，在elasticseacher.yml设置值discovery.minimum_master_nodes。")])]),a("li",[a("p",[l._v("对于所以的候选节点按照node id进行排序，每一次选举，每一个节点都要把自己知道的服务节点 按照 node id进行排序，选出第一个节点，暂定该节点为master节点。")])]),a("li",[a("p",[l._v("如果对某一个节点的票数到达一定量级后（候选节点数量 / 2 + 1），并该节点也自己个给自己投一票，那这是该节点就成为master节点，否则重新选举，知道到达满足的条件。")]),a("p",[l._v("补充：")]),a("ul",[a("li",[l._v("这里的node id 是string类型。")]),a("li",[l._v("master节点职责是集群，节点和索引的管理，不负责文档级别的管理，data节点可以关闭http的功能。")])])])]),a("h2",[l._v("14、jvm")]),a("h3",[l._v("14.1、jvm模型")]),a("p",[a("img",{attrs:{src:i("f762"),alt:""}})]),a("p",[l._v("jvm模型中包含了：程序计数器，本地方法栈，方法区（也叫元数据），堆，虚拟机栈")]),a("ul",[a("li",[a("p",[l._v("程序计数器：该内存可以看成一块很小的内存空间，主要是保存了当前线程执行节点码的行号指示器，该计数器，只是针对于java程序，对于native方法计数器为undefined。该区域是java没有定义out of memory error的区域，也就是说，该区域是可以发生内存泄漏的危险。")])]),a("li",[a("p",[l._v("堆（heap）：在java中，将堆划分到了两个不同的区域，被分为老年代，新生代。在新生代中有被划分为了三个区域，eden，from survivor，to survivor。")]),a("ul",[a("li",[l._v("堆是java中最大的一块内存区域。也被所以线程共享的，里面存放了java对象实例和数组。")]),a("li",[l._v("堆是垃圾回收器主要管理的区域，也被称为GC区。")]),a("li",[l._v("java堆的分类： "),a("ul",[a("li",[l._v("从内存回收分类：可以分为老年代，新生代。新生代又被分为三个区域，比列为8:1:1")]),a("li",[l._v("从内存分配来分类：为了解决线程安全的问题，可以划分为多个线程私有区域。")])])]),a("li",[l._v("可以通过参数：xmx - xms来指定运行时堆空间的大小，初始默认值是：最小值是物理内存的64分之1，最大内存是物理内存的4分之1。")])])]),a("li",[a("p",[l._v("虚拟机栈：也叫栈，每一个线程都会创建一个虚拟机栈，其内部保存这一个栈帧，对应这一次方法的调用。")]),a("p",[l._v("栈的作用：主管java程序运行，里面保存了局部变量，部分结果和方法的入口和返回。")]),a("ul",[a("li",[l._v("局部变量：存储着基本数据类型，如果引用数据类型，是存储在堆内存中的，而局部变量表中存在的堆内存中的引用地址。")]),a("li",[l._v("操作数栈：操作数运算时一块临时存放操作数。")]),a("li",[l._v("动态链接：将代码的符号引用转换成在方法区上直接引用。")]),a("li",[l._v("方法出口：保存着该方法执行完成后返回到上一个方法的位置。")])]),a("p",[l._v("栈的大小是可以固定也可以动态的：")]),a("ul",[a("li",[l._v("在固定大小的情况下：当栈调用的深度大于jvm定义的范围，就会抛出 stack over flow error异常，栈溢出。")]),a("li",[l._v("在动态扩展的情况下：若扩展时，无法在向jvm申请内存时，就会抛出out of memory error异常。")])])]),a("li",[a("p",[l._v("方法区：也叫元数据区，于堆一样，是所有线程共享的一块内存区域，里面存储着类信息，常量，静态变量，编译后代码缓存。")])])]),a("h3",[l._v("14.2、类加载的过程：")]),a("blockquote",[a("p",[l._v("类加载主要分为七个步骤：分别为 加载，验证，准备，解析，初始化，使用，卸载")])]),a("ul",[a("li",[a("p",[l._v("加载：主要是负责将class类的二进制文件在到内存中。")]),a("ul",[a("li",[l._v("根据类全限定名将二进制文件数据加载到内存中。")]),a("li",[l._v("加载的二进制数据转换对应数据结构。")]),a("li",[l._v("为加载在内存中的数据结构创建class对象。")])])]),a("li",[a("p",[l._v("验证：验证的目标住主要是判断加载class类是否合法，不会危害java虚拟机。")]),a("ul",[a("li",[l._v("文件格式的验证：主要针对class文件规范是否合法，常量池中是否有不支持的类型。")]),a("li",[l._v("元数据的验证：主要是验证该class是否继承了不能被继承类。是否有父类，继承关系等。")]),a("li",[l._v("字节码验证：这个环节的验证是最麻烦的，主要是验证程序的的语意是否合法，数据流和控制流是否合法，主要是针对方法验证，验证方法中流程的跳转，类型的转换是否合法。")]),a("li",[l._v("符号引用验证：主要是保证后面动作可以正确的执行。")])])]),a("li",[a("p",[l._v("准备：主要是为静态变量分配内存空间，初始化默认，这个分配的内存空间都在方法区中。")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-java"}},[a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[l._v("public")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[l._v("static")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-type"}},[l._v("int")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-variable"}},[l._v("i")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-operator"}},[l._v("=")]),l._v(" "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[l._v("123")]),l._v(";  "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[l._v("// 在准备阶段，为变量i分配内存空间，初始化值，i = 0; 如果是引用类型赋值为null。")]),l._v("\n")])])]),a("li",[a("p",[l._v("解析：主要是将符号引用转换成直接引用。解析动作不一定在初始化之后，也可以在初始化之前。")])]),a("li",[a("p",[l._v("初始化：这是类加载的最后一步，初始化的时候，才是真正开始执行java程序的代码。就是创建初始化静态变量，和静态代码块。")])]),a("li",[a("p",[l._v("使用。")])]),a("li",[a("p",[l._v("卸载。")])])]),a("h3",[l._v("14.3、jvm加载class的原理：")]),a("ul",[a("li",[l._v("java语言是一个具有动态加载的解释性语言，只有class在被使用到的时候，才会被jvm加载，当程序运行时，jvm会根据自己的规则加载到内存中去，并组织成一套完整应用程序，这个类加载的过程确其实是由类加载器 classLoader完成的，class loader其实也是一个类，这个的本质就是将硬盘上文件加载到内存中。")]),a("li",[l._v("类加载的方式可以分为两种类型：显式加载和隐式加载 "),a("ul",[a("li",[l._v("显示加载：就是通过class.forname 的方式来对类进行加载。")]),a("li",[l._v("隐式加载：就是通过new 等关键词进行加载对象，但是其背后原理还是调用联 class loader来进行的类加载。")])])]),a("li",[l._v("任何一个java的应用程序，都是由很多个class组成，当程序启动的时候，只会把需要的class加载到jvm中去，其他类只有被使用的时候，才会被加载jvm中去，采用这样的方式，可以提高jvm加载的速度，没有必要一次性把全部的class加载到jvm中，另一方面就是可以减少jvm内存的开销。另外，在java中，每一个类或接口都会对应这一个class文件，这些class文件可以看成一个个动态的加载单元，只有一部分类被修改时，才会重新编译这些修改的类，不需要重新编译所有的文件，因此加快了编译速度。")])]),a("h3",[l._v("14.4、java内存分配：")]),a("ul",[a("li",[l._v("寄存器：我们无法控制。")]),a("li",[l._v("静态域：定义的静态变量。")]),a("li",[l._v("常量池：保存一些定义的常量（final修饰的）和一些文本修饰符号引用，全限定名，字段名称和描述，方法名称和描述。")]),a("li",[l._v("堆内存：new的对象实例，数组，由java虚拟机垃圾自动回收管理，存取的速度较慢。")]),a("li",[l._v("栈内存：基本数据类型，对象实例引用变量，速度快，可以共享，但是大小和生命周期必须确定，缺乏灵活性。")])]),a("h3",[l._v("14.5、GC是什么：")]),a("ul",[a("li",[a("p",[l._v("GC是垃圾回收器的意思（Gabage collection）。在应用中内存处理是比较重要的，如果内存处理不适当的话，容易引起程序崩溃和程序的不稳定。java提供的GC功能可以自动的监控对象是超过了作用域，从而达到自动回收的目的。")])]),a("li",[a("p",[l._v("在java应用中，不需要开发人员去手动的释放对象所占用的堆内存空间，是由java虚拟机自动去释放。在jvm中，是由一个垃圾回收的线程来控制的，是由低优先级的，只有在jvm空闲的时候，堆内存不足的时候才会触发执行，扫描那些对象或数据没有引用时，就会被添加到垃圾回收的集合中，进行回收。")])]),a("li",[a("p",[l._v("开发人员不能实时的调用垃圾回收器，来对某一个对象进行回收。是由jvm自动去判断的，判断的依据就是 某一个对象长时间没有使用或者没有引用的时候，才会被垃圾回收器回收。")])]),a("li",[a("p",[l._v("开发人员可以手动的调用System.gc方法和Runnable.gc方法，但是调用gc方法，但是不一定会触发垃圾回收。什么时候触发是由jvm来定的。")])])]),a("h3",[l._v("14.6、内存泄漏：")]),a("ul",[a("li",[a("p",[l._v("内存泄漏是指一个不被程序使用的对象或变量一直占用着内存空间。")])]),a("li",[a("p",[l._v("在java中，存在垃圾回收机制，所以当内存中存在长时间没有使用的对象，变量或没有引用的对象，变量时，就会被垃圾回收器收集。从而从内存中清除。")])]),a("li",[a("p",[l._v("java中内存泄漏的情况可能是一个长生命周期的对象一直持有者一个短生命周期的对象，这个短生命周期的对象就不能被垃圾回收器回收。这是java就容易发生内存泄漏。")]),a("p",[l._v("举个例子：创建了一个对象，但是我在程序的后面在也不会使用该对象了，但是该对象的一直在另一个对象中引用了，这是java垃圾回收器就无法回收该对象所占用的内存空间，因为该对象一直被其他对象引用者，存在引用，垃圾回收器就无法回收。")]),a("p",[l._v("另外：比如存在一个内部类的对象，这个内部类对象被长期引用，既是这个外部类，没有被其他对象使用了，但是外部类一直被内部类引用者，所以垃圾回收器就无法回收。也就会造成内存泄漏。")])])]),a("h3",[l._v("14.7、finalize方法：")]),a("p",[l._v("该方法在的用途有两个：")]),a("ul",[a("li",[l._v("finalize方法释放本地方法申请的内存。")]),a("li",[l._v("作为终结条件。")])]),a("p",[l._v("java中有垃圾回收，可以对new出来的对象，而且不在使用的对象回收。但是java中有些情况下，申请内存不通过new进行，这种情况垃圾回收就不能进行回收。这个时候finalize方法就会发挥作用，对这部分特殊申请的内存进行回收。")]),a("h3",[l._v("14.8、GC算法：")]),a("ul",[a("li",[a("p",[l._v("标记清除算法：")]),a("p",[l._v("是垃圾回收里面最基础的算法，就是标记那些需要回收的对象，然后进行统一回收。这种算法有两种缺陷：")]),a("ul",[a("li",[l._v("在回收后，内存中存在大量的内存碎片。")]),a("li",[l._v("标记需要回收的对象效率不高，无法解决。")])])]),a("li",[a("p",[l._v("复制算法：")]),a("p",[l._v("就是将内存分为两分，就是将不需要回收的对象复制到第二块内存中，然后对第一块内存进行回收，第一块内存回收完成后，在把第二块内存上对象，复制到第一块内存中去。")]),a("ul",[a("li",[l._v("这种方式内存的代价太高，每一次都要浪费一半的内存，只有在回收时，才能利用。")])]),a("p",[l._v("于是对该算法进行了改进：将内存不再按照1：1分，按照8:1：1进行分配，较大的 内存区域叫eden，较小的内存区域叫survior区，每次都会先使用eden区域，当eden区域满了后，就将对象复制到第二块内存中，然后清除eden，当eden存储的对象较多时，以至于survior区域不够时，就会将这些对象使用分配担保机制复制到老年代中。")])]),a("li",[a("p",[l._v("标记整体：")]),a("p",[l._v("就是先将需要回收的对象标记出来，将没有标记的对象移动到一端去，然后回收超出边界的对象，这样就不会在产生内存碎片。")])]),a("li",[a("p",[l._v("分代收集：")]),a("p",[l._v("现在jvm采用的就是分代收集算法，根据对象生命周期不同，将堆分为新生代和老年代，一般在新生代的对象，生命周期比较短，在新生代上使用复制算法，在老年代上使用标记整理或者标记清除法。")])])]),a("h3",[l._v("14.9、双亲委派机制：")]),a("p",[l._v("在每一个类加载器，都有一个独立的类名称空间，类加载器就是通过全限定名将对应的class文件加载到jvm中，然后在转换成class对象。")]),a("p",[l._v("类加载器的分为：")]),a("ul",[a("li",[l._v("启动类加载器：bootstrap class loader 是java核心的类加载器，不能被外部引用，用来加载java_home/lib 下的东西。")]),a("li",[l._v("扩展加载器：来用加载一些扩展类到jvm系统中去。")]),a("li",[l._v("系统加载器：system class loader 用来加载class path下文件。")]),a("li",[l._v("自定义加载器。")])]),a("p",[l._v("双亲委派模型：当需要加载一个类的时候，类加载器并不会自己马上加载该类，而是交个他的父类，如果继承很深，会一直找到最顶级的父类，由父类去加载，如果父类加载不出，子类才会尝试去加载。")]),a("h3",[l._v("14.10、Minor GC 和 full GC")]),a("h4",[l._v("14.10.1、minor GC：")]),a("ul",[a("li",[l._v("对于复制算法的时候，当年轻代eden区域满了的时候，就会触发Minor GC，将eden和s0复制到s1上。")]),a("li",[l._v("注意：如果当某一个对象的存活时间超过一定的Minor GC次数，该对象就会的直接进入老年代，不在分配到s0上。jvm默认进行15次Minor GC次数（jvm参数：XX:+MaxTenuringThreshold）。")])]),a("h4",[l._v("14.10.2、full GC：")]),a("ul",[a("li",[l._v("用于清理整个堆空间，显示调用System.gc()。")]),a("li",[l._v("老年代空间不足。 "),a("ul",[a("li",[l._v("大对象直接进入老年代。")]),a("li",[l._v("多次Minor GC后，有对象进入老年代。")]),a("li",[l._v("Minor GC时，eden和s0向s1复制对象的时候，大于s1区域可用的内存，会直接将对象转移到老年代。")]),a("li",[l._v("对象动态年龄判断通过后，转移到老年代的时候。")])])])]),a("h4",[l._v("14.10.3、频繁Full GC可用的问题：")]),a("ul",[a("li",[a("p",[l._v("linkedBlockingQueue：")]),a("p",[l._v("当数量很大的时候，队列无限到的时候，就会无限存放数据，最终会导致allocation fauilure的full GC。")])]),a("li",[a("p",[l._v("线程池：")]),a("p",[l._v("使用Executors.newFixedTheadPoll(nTheads)构造线程池处理消息，结果由于消息量很大，造成内存消耗过快，频繁full GC，其实本质就是队列无限存放数据。")])]),a("li",[a("p",[l._v("每次请求消耗的内存很大。")])]),a("li",[a("p",[l._v("也可能是jvm堆内存分配过低。")])])]),a("h2",[l._v("15、分布式理论")]),a("h3",[l._v("15.1、CAP")]),a("p",[l._v("CAP是指在一个分布式系统中，一致性，可用性，分区容错性。在分布式系统中，一般需要满足CP和AP即可，不存在CAP。")]),a("ul",[a("li",[l._v("一致性（Consistency）：在分布式系统中，所有的备份数据，在同一时刻是全部是应该是一致的。（一致性分为：强一致性，弱一致性和最终一致性）")]),a("li",[l._v("可用性（Availability）：在集群中，如果一部分节点宕机或出现其他情况导致不能正常提供服务时，但是集群整体还是的可以正常提供服务的。")]),a("li",[l._v("分区容错性（Partition tolerance）：系统如果不能在一定时间内到时数据的一致性，就意味着发生了分区容错，就必须在C和A之间作出选择。")])]),a("p",[l._v("CP：相当于每一个请求操作都需要在集群之间保证强一致，而分区会导致这个同步时间无限延长（就是说：在处理了一次非读操作后，需要将数据同步到所有集群服务中，只有等集群服务坐下正确的响应后，此时同步才结束。），一旦发生网络故障或者数据丢失的情况，就需要降低用户的体验度，只有等待所有数据达成一致后，用户才会进行正常访问。设计成CP的系统其实很少，但是最典型的就是分布式数据库，如：redis，hbase等。")]),a("p",[l._v("AP：要高可用和分区，放弃了一致性，一旦发生了分区，节点和节点之间就有可能失去联系，为了高可用，每个节点只能使用本地的数据提供服务，这样会导致全局数据不一致的情况。")]),a("h3",[l._v("15.2、幂等性：")]),a("ul",[a("li",[l._v("幂等性就是用户对同一操作发起一次或者多次请求的时候，处理的结果是一致的，不会因为多次请求造成的结果不一致。")]),a("li",[l._v("在增删改查四个操作中，需要主要的增加和修改，查询对于结果不会发生改变，删除只会执行一次，响应一行的数据，用户在多次操作后，查询多次结果不会发生变化，删除也只存在一个筛选条件的数据，但是增加，修改重复提交就会出现问题。")])]),a("p",[l._v("解决方案：")]),a("ol",[a("li",[l._v("MySQL中设置唯一主键ID。")]),a("li",[l._v("使用redis或者zookeeper的分布式锁。")])]),a("p",[l._v("什么是幂等性：")]),a("p",[l._v("​ 在编程中，幂等性操作就是一个操作执行一次或者多次后，造成的结果还是根执行一次的结果一样。")]),a("p",[l._v("幂等性的场景：")]),a("ul",[a("li",[l._v("在分布式，微服务中，可能由于网络波动的情况，造成重复请求。")]),a("li",[l._v("用户重复操作，由于网络原因，造成用户重复操作，重复提交表单等。")]),a("li",[l._v("应用重试机制。")])]),a("p",[l._v("解决幂等性：")]),a("ul",[a("li",[l._v("唯一索引：防止脏数据，比如：用户重复注册，用户名称字段添加唯一索引。")]),a("li",[l._v("token机制：防止重复提交，比如：请求先获取token，在拿着token去请求，后台服务验证通过后，就删除远程的token，在进行操作。")]),a("li",[l._v("悲观锁：数据库的悲观锁，java中Synchronized。")]),a("li",[l._v("乐观锁：lock锁，数据库乐观锁。")]),a("li",[l._v("分布式锁。")])]),a("h2",[l._v("16、Nacos")]),a("h3",[l._v("16.1、Nacos选举算法：")]),a("p",[l._v("Nacos集群默认是AP模式（放弃了数据一致性），但是也可以支持CP模式，需要进行转换。")]),a("p",[l._v("Nacos中的选举算法采用的是RAFT算法，里面包含了三种角色：")]),a("ul",[a("li",[l._v("leader：唯一负责处理客户端的写请求节点，但是也可以处理客户端的读请求，同事也负责日志复制的工作，整个集群中只能有一个leader节点。")]),a("li",[l._v("candidate：leader节点候选人，是有可能成为leader节点的节点。")]),a("li",[l._v("follower：可以处理客户端的读请求，负责同步来自leader节点的日志，接受来自candidate节点投票请求，发起投票，在失去leader节点后，转变成candidate节点，发起投票。")]),a("li",[l._v("term：任期，一个新的leader会有一个新的任期，这个新的任期是在上一个leader的任期基础上获取的。")])]),a("p",[a("strong",[l._v("开始选举")])]),a("p",[l._v("follower在心跳超时范围内没有接受到来自leader心跳，则认为leader已经挂了，follower就转换candidate角色，自己本地记录term加一，向自己投一票，并向其他节点发起投票请求，让其他节点投票给自己。")]),a("p",[a("strong",[l._v("发起投票")])]),a("p",[l._v("如果在期间，我的接受到了其他节点的投票时，会先判断，发来投票的请求term不能小于我本地的term值，并且在我的term内，我还没有发起投票请求，判断我的请求log编号不能小于我的编号，这样才会将票投出去，如果在投票期间接受到了多个投票请求，只会处理接受到第一个投票请求。")]),a("p",[a("strong",[l._v("处理结果")])]),a("p",[l._v("在选举的过程中，如果所有的candidate的票数都相同，那么会进行重新选举，但是在选举时，会添加一个随机选举时间，就是说在发起选举时，每一个节点都会阻塞一点时间。")]),a("ul",[a("li",[l._v("接受到过半的票后，就成为了新的leader，并以广播的形式，通知其他节点，把自己term同步到其他节点。")]),a("li",[l._v("当其他的candidate接受到来之leader广播后，就变成了follower，更新自己term值。")]),a("li",[l._v("经过一段时间后，如果还没有票数过半的candidate，就会重新发起选举。")])]),a("h3",[l._v("16.2、Nacos中的保护阈值：")]),a("p",[l._v("nacos中的保护阈值时保护每一个服务的，值是0-1，比如某一个服务集群中，存在10个实例，保护阈值设置成0.5时，就表示在集群中，如果出现 10 * 0.5个实例挂掉后，就会触发服务保护，触发保护后，一开始是10个服务实例在提供服务，但是经过一段时间后，健康的服务实例就只存在5个了，这时集群接受的请求来是按照10个实例来接受的，但是集群中只剩下5个服务了，所以处理请求的能力下降，可能会导致剩下的5个服务都挂掉，所以为保护剩下的服务，就会在处理请求时，进行负载均衡是，就会按照之前10个实例时负载均衡，这样在请求中，有的可能负载到健康的服务实例，有点请求可能负载到死亡的服务实例。")]),a("h3",[l._v("16.3、Nacos的就近访问：")]),a("p",[l._v("在nacos中，一个服务可以有多个实例，并可能给这些实例设置cluster-name，这样就可以将这些实例划分为更小集群。现在有一个服务A想调用服务B时，就会根据服务A所在cluster-name去查找服务B集群中cluster-name相同服务集群。简单的来说就是判断两个服务的cluster-name来判断两个服务是不是同一个集群里的。")]),a("h3",[l._v("16.4、Nacos是CP还是AP：")]),a("p",[l._v("通常情况下，nacos即支持CP，也支持AP，默认情况下，nacos集群是AP模式，如果注册的节点时临时节点，那就是AP，如果是非临时节点，既是CP。")]),a("h3",[l._v("16.5、Nacos的命名空间：")]),a("p",[l._v("命名空间就是namespace，默认情况下，都是属于public命名空间的。我们可以在nacos中新增命名空间，就相当于开辟了一块新的空间，用来存放服务信息和配置信息，命名空间是独立的，我们可以利用命名空间来配置不同的环境，如：测试环境，开发环境，生产环境等。")]),a("h3",[l._v("16.6、注册中心采用CP还是AP比较好：")]),a("p",[l._v("注册中心还是采用AP模式比较好，因为在集群环境下，如果采用了CP模式的话，就需要等下集群下所有的数据都达到一致时，才能提供服务，如果服务在频繁上下线时，集群中服务特别的多时，就会造成注册中心压力过大，导致注册中心频繁在同步数据，同步时间延迟，注册中心提供服务时能力下降。如果是采用了AP模式的话，注册中心是一直处于可用状态，就算提供服务中存在了不健康的服务时，在client中也可以采用服务容错和重试机制来解决，对于注册中心而言，就的不需要频繁的在同步数据，保证最终一致性就可以了。")]),a("h2",[l._v("17、zookeeper")]),a("h3",[l._v("17.1、zookeeper是什么：")]),a("p",[l._v("在分布式系统zookeeper是用来管理和监控集群中服务。")]),a("p",[l._v("特点：")]),a("ul",[a("li",[l._v("数据的最终一致性：在客户端看到的数据都是一致的。")]),a("li",[l._v("可靠性：服务器保存的了消息，那他就一直存在。")]),a("li",[l._v("独立性：不同客户端相互不影响。")]),a("li",[l._v("实时性：zookeeper不能保证两个客户端同时得到刚刚更新的数据。")]),a("li",[l._v("原子性：更新状态执行成功和失败，没有第三个状态。")])]),a("h3",[l._v("17.2、应用场景：")]),a("ul",[a("li",[a("p",[l._v("数据的订阅和发布：")]),a("p",[l._v("就是对数据的管理，就是可以将数据发布到zookeeper节点上，订阅者可以实时获取到最新发布的数据，实现本地配置动态更新。")]),a("p",[a("strong",[l._v("数据配置的特点：")])]),a("ul",[a("li",[l._v("数据量要小于1M，每一个zookeeper节点上只能存储1M的数据。")]),a("li",[l._v("数据内容在运行时会动态的发生变化。")]),a("li",[l._v("集群内，所有数据都是一样的。")])]),a("p",[a("strong",[l._v("采用推拉模式：")])]),a("ul",[a("li",[l._v("推：服务器会推给注册了wathcer事件的事件通知。")]),a("li",[l._v("拉：客户端获取得通知后，然后主动到服务端拉取最新数据。")])])]),a("li",[a("p",[l._v("命名服务：")]),a("p",[l._v("命名服务是表示在集群中，可以通过一个服务的名称获取资源信息和服务地址信息，zookeeper创建了的全局的路径，这个路径就可以作为一个名字。")])])]),a("h3",[l._v("17.3、zookeeper如何保证主从节点的状态同步：")]),a("p",[l._v("zookeeper的核心就是原子广播，这个机制保证了各个server之间的同步。实现这个机制的协议叫做zab协议，zab协议有两种模式：")]),a("ul",[a("li",[l._v("恢复模式：当服务启动时或者选举出了leader节点后，zab就进入了恢复模式，当leader被选举出来后，大多数的server就会完成和leader同步，然后就结束了恢复模式。")]),a("li",[l._v("广播模式：一但leader和大多数的server完成了数据同步后，就可以进入广播模式，广播模式简单的理解就是负责把leader的消息同步到所有server上。")])]),a("h2",[l._v("18、Seata 分布式事务")]),a("p",[l._v("seata是一款处理分布式事务的一套解决方案，提供了高性能和简单易用的分布式事务服务，seata为用户提供了AT，TCC，SAGA和XA模式的事务。事务具有四个性质："),a("strong",[l._v("原子性")]),l._v("，"),a("strong",[l._v("一致性")]),l._v("，"),a("strong",[l._v("隔离性")]),l._v("，"),a("strong",[l._v("持久性")]),l._v("，在分布式系统中，是分布式事务就是需要保证每一个节点之间的数据一致性问题。")]),a("p",[l._v("在seata中分为三个模块：")]),a("ul",[a("li",[l._v("TC：事务协调者，维护全局和分支事务的状态，驱动事务的提交和回滚。")]),a("li",[l._v("TM：事务管理器，定义全局事务的范围，开始全局事务，提交全局事务，回滚全局事务。")]),a("li",[l._v("RM：资源管理器，管理分支事务处理的资源，于TC交谈以及注册分支事务和报告分支事务的状态，并驱动分支事务的提交和回滚。")])]),a("p",[l._v("在seata中，分布式事务提交流程：")]),a("ul",[a("li",[l._v("TM开启分布式事务，TM向TC上注册全局事务记录。")]),a("li",[l._v("按照具体业务场景，编排数据库，服务器内部资源，RM向TC汇报资源准备状态。")]),a("li",[l._v("TM结束分布式事务，事务一段结束，TM通知TC提交还是回滚分布式事务。")]),a("li",[l._v("TC汇总分布式事务信息，决定是提交事务还是回滚事务。")]),a("li",[l._v("TC通知所有的RM提交、回滚事务，事务第二段结束。")])]),a("p",[l._v("TM和RM作为seata的client端和业务系统是集成在一起的，TC作为Seata的服务端独立部署的。seata服务端存储支持三种模式：")]),a("ul",[a("li",[l._v("file：单机模式。")]),a("li",[l._v("DB：高可用模式。")]),a("li",[l._v("redis：redis模式。")])]),a("p",[l._v("使用DB模式需要在数据库创建三张表：")]),a("ul",[a("li",[l._v("global_table：全局事务表。")]),a("li",[l._v("branch_table：分支事务表。")]),a("li",[l._v("lock_table：全局锁。")])]),a("p",[l._v("Seata的全局事务的处理过程：")]),a("ul",[a("li",[l._v("执行阶段：执行分支事务，并保证执行结果满足是可以回滚和持久化的。")]),a("li",[l._v("完成阶段：根据执行阶段的结果来形成决议，通过TM发出全局事务是提交还是回滚的请求个TC，TC命令RM驱动分支事务执行commit和rollback。")])]),a("h3",[l._v("18.1、XA规范：")]),a("p",[l._v("XA模式是一个强一致性和中性化。XA模式对数据库占用时间较长，性能有点低。XA属于两阶段提交。")]),a("ol",[a("li",[l._v("第一阶段进行事务注册，将事务注册到TC中，执行SQL语句。")]),a("li",[l._v("第二阶段TC判断第一个阶段执行的结果，如果没有错误，就提交事务，反之回滚事务。")]),a("li",[l._v("在第一阶段和第二阶段的过程中，事务会一直占用着数据锁，所以性能较低，但是所有的事务要么一起成功，要么一起失败，具有强一致性的。")])]),a("p",[l._v("XA规范：是X/OPEN组织定义的分布式事务处理标准，XA描述了全局事务管理器和局部资源管理器之间的接口，XA规范的目的是多个资源在同一个事务内访问，这样可以是ACID在不同的应用中保持有效。XA规范使用的是两段提交，来保证事务的提交和回滚的特定事务，")]),a("h3",[l._v("18.2、AT模式：")]),a("p",[l._v("AT模式的主要特点：")]),a("ul",[a("li",[l._v("最终一致性。")]),a("li",[l._v("性能高于XA。")]),a("li",[l._v("只在第一阶段获取锁，在第一阶段执行完成后就释放锁了。")])]),a("p",[l._v("在第一阶段中，seate会拦截业务sql的执行，首先先解析sql语句，找到要操作业务数据，在数据被操作前，先记录下该数据，记录在undo log 中，然后在执行业务sql，操作业务数据，操作完成后，再次保存数据到 redo log 中，最后生成行锁，这个操作都是在本地事务完成，这样保证了原子性。")]),a("p",[l._v("在第二阶段中，负责整体的回滚提交，如果在第一阶段中，有事务没有通过，就执行全局回滚，否则执行全局提交，回滚就用到了第一阶段中记录的 undo log， 当事务执行完成后，就释放掉资源并删除记录日志。")]),a("p",[a("img",{attrs:{src:i("56d5"),alt:""}})]),a("h3",[l._v("18.3、TCC模式：")]),a("p",[l._v("TCC模式是分为三个阶段：prepare， commit，cancel。")]),a("p",[l._v("流程：")]),a("ul",[a("li",[l._v("TM向TC申请全局事务XID，传播给各个子调用。")]),a("li",[l._v("子调用的所在TM向TC注册分之事务，并执行本地prepare，并向TC报告执行结果。")]),a("li",[l._v("TC根据子调用的执行结果，执行第二阶段是执行commit还是rollback。")])]),a("p",[a("img",{attrs:{src:i("c688"),alt:""}})]),a("p",[l._v("特点：")]),a("ul",[a("li",[l._v("优点：不依赖本地事务。")]),a("li",[l._v("缺点：回滚逻辑需要自己手动实现，业务侵入性比较大。")])]),a("h3",[l._v("18.4、Saga模式：")]),a("p",[l._v("Saga事务就是将一个长事务分解成一个个sub事务，每一个sub事务都有自己的补偿动作，用于回滚事务，如果sub事务提交过程中心出现了异常，逆向进行事务补偿。")]),a("p",[l._v("流程：")]),a("ul",[a("li",[l._v("在saga模式中，业务流程中每一个参与者都提交本地事务，当某一个参与者事执行失败，则补偿前面已经成功了的参与者，一阶段正向服务和第二阶段补偿服务都是由业务开发实现。")])]),a("p",[a("img",{attrs:{src:i("b88e"),alt:""}})]),a("p",[l._v("特点：")]),a("ul",[a("li",[l._v("一阶段提交本地事务，无锁，高性能，事件驱动架构，参与者可以异步执行，高吞吐，补偿服务易于实现。")]),a("li",[l._v("不保证事务隔离性。")])]),a("h3",[l._v("18.5、各个模式的对比：")]),a("table",[a("thead",[a("tr",[a("th",[l._v("模式")]),a("th",[l._v("优点")]),a("th",[l._v("缺点")])])]),a("tbody",[a("tr",[a("td",[l._v("AT")]),a("td",[l._v("对代码无侵入，并发高，本地锁在第一阶段就会释放，不需要本地数据库对XA协议的支持。")]),a("td",[l._v("只能用在支持ACID的关系型数据库上，SQL解析还不能执支持全部语法。")])]),a("tr",[a("td",[l._v("TCC")]),a("td",[l._v("不依赖本地事务。")]),a("td",[l._v("事务回滚依赖手动代码实现，业务侵入性大。")])]),a("tr",[a("td",[l._v("Saga")]),a("td",[l._v("第一段提交本地事务，无锁，性能高，异步执行，补偿容易实现。")]),a("td",[l._v("不支持隔离性。")])]),a("tr",[a("td",[l._v("XA")]),a("td",[l._v("继承了XA协议的优势，事务具有强一致。")]),a("td",[l._v("同样继承了XA协议，分支事务开启时间长，并发事务低。")])])])]),a("h2",[l._v("19、数据结构")]),a("p",[a("strong",[l._v("数据结构在线实现存储过程：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html")])]),a("h3",[l._v("19.1、栈：")]),a("p",[l._v("栈：stack是限制插入和删除只能在同一个位置操作的表，该位置是表末端，也叫栈顶。")]),a("p",[l._v("特点：")]),a("ul",[a("li",[l._v("后进先出，对栈操作只有push和pop操作。push是插入，pop是删除。")]),a("li",[l._v("先push的元素会被放在栈低，后push的元素会被放在栈顶。")])]),a("p",[a("img",{attrs:{src:i("a61e"),alt:""}})]),a("h3",[l._v("19.2、队列：")]),a("p",[l._v("队列是一种特殊的线性表，特殊在于只有允许在表的前端进行删除操作，而在表的后端进行插入操作。插入那端称为队尾，删除那端称为队头。")]),a("p",[a("img",{attrs:{src:i("be45"),alt:""}})]),a("h3",[l._v("19.3、链表：")]),a("p",[l._v("链表是一个数据结构，链表在进行循环遍历的时候，效率不是很高，但是插入和删除的效率比较高。")]),a("p",[a("img",{attrs:{src:i("a744"),alt:""}})]),a("h3",[l._v("19.4、散列表：")]),a("p",[l._v("散列表也叫哈希表，是一种查询算法，散列表算法在查询元素的时候不需要进行一系列关键词比较的操作。散列表算法希望尽量做到不需要经过任何比较，通过一次存取就能得到所查询的数据元素，可以根据HashMap的实现原理做为参考。")]),a("p",[l._v("用来构造散列表的函数：")]),a("ul",[a("li",[l._v("直接寻值法：取关键字或关键字的某一个线性函数作为散列表中的值。")]),a("li",[l._v("数字分析法：")]),a("li",[l._v("平方取值法：取关键字平方后中间几位作为散列表的地址。")]),a("li",[l._v("折叠法：将关键子字分割成几部分，然后这几部分叠加和作为散列表的地址。")]),a("li",[l._v("随机数法：选取一个随机函数，将关键字给随机函数，得到的值就作为散列表的地址。")])]),a("h3",[l._v("19.5、排序二叉树：")]),a("p",[l._v("普通的二叉树每一个节点都需要满足：左子树所有的节点值小于它的根节点值，且右子数所有节点的值都大于它的根节点值，这样的二叉树就是排序二叉树。")]),a("h4",[l._v("19.5.1、插入操作：")]),a("p",[l._v("首先从根节点开始往下找，找到自己需要插入的位置，具体流程：")]),a("ul",[a("li",[l._v("新节点与当前节点进行比较： "),a("ul",[a("li",[l._v("如果相同，则表示已经存在了，不能在插入。")]),a("li",[l._v("如果小于当前节点，则到左子树中寻找。")]),a("li",[l._v("如果大于当前节点，则在右子树中查找。")])])])]),a("p",[a("img",{attrs:{src:i("9652"),alt:""}})]),a("h4",[l._v("19.5.2、删除操作：")]),a("p",[l._v("删除操作分为三种情况：")]),a("ul",[a("li",[l._v("删除的节点无子节点。 "),a("ul",[a("li",[l._v("对于删除的节点无子节点，可以直接删除即可。")])])]),a("li",[l._v("需要删除的节点只有一个子节点。 "),a("ul",[a("li",[l._v("替换要删除的节点为其子节点。")])])]),a("li",[l._v("需要删除的节点有两个子节点。 "),a("ul",[a("li",[l._v("需要先找到需要替换的节点，接着替换要删除的节点，然后在把需要删除的节点删除即可。")])])])]),a("p",[a("img",{attrs:{src:i("0e1c"),alt:""}})]),a("h4",[l._v("19.5.3、查询操作：")]),a("p",[l._v("查询的流程：")]),a("ul",[a("li",[l._v("先和根节点进行比较，如果相同就直接返回。")]),a("li",[l._v("如果小于根节点，就在左子树中递归查询。")]),a("li",[l._v("如果大于根节点，就在右子树中递归查询。")])]),a("p",[a("strong",[l._v("在排序二叉树中，可以很快的就查询到最大值（最右最深的子节点）和最小值（最左最深的子节点）。")])]),a("h3",[l._v("19.6、红黑树：")]),a("p",[l._v("R-B-tree全称叫：read black tree翻译叫红黑树，它是一种特殊的二叉查询树，红黑树上每一个节点上都有存储位置表示节点的颜色。")]),a("p",[l._v("特点：")]),a("ul",[a("li",[l._v("每一个节点颜色是红色或者黑色。")]),a("li",[l._v("根节点都是黑节点。")]),a("li",[l._v("每一个叶子节点都是黑色。【注意：这里的叶子节点，是指为空的叶子节点。】")]),a("li",[l._v("如果一个节点为红色，则它的子节点必须是黑色。")]),a("li",[l._v("从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。")])]),a("h3",[l._v("19.7、B-Tree：")]),a("p",[l._v("B-Tree 又叫多路平衡树，一颗M阶的B-tree的特征：")]),a("ul",[a("li",[l._v("树中每一个节点至多有m个子节点。")]),a("li",[l._v("除了根节点和叶子节点外，其他节点至少m / 2 个孩子。")]),a("li")]),a("h1",[l._v("20、liunx")]),a("h2",[l._v("20.1、如何排查CPU爆了问题:")]),a("p",[l._v("一般造成CPU爆满情况，一般都是只有两种情况：")]),a("ul",[a("li",[l._v("形成了死循环。")]),a("li",[l._v("造成死锁。")])]),a("p",[l._v("解决方法：")]),a("ol",[a("li",[a("p",[l._v("使用 top -c 命名查询出，cpu使用100%的进程。")]),a("p",[l._v("-c 实现程序名称以及参数")]),a("p",[a("img",{attrs:{src:i("3634"),alt:""}})])]),a("li",[a("p",[l._v("在使用 top -H -p 进程号，查看该进程下的线程情况占用情况。（-H是大写字母）")]),a("p",[l._v("-H 设置线程模式。-p 显示指定的进程。")]),a("p",[a("img",{attrs:{src:i("de3e"),alt:""}})])]),a("li",[a("p",[l._v("此时看到就是该进程下的所有线程列表。这是就可以找出异常的线程号，在通过日志分析，找出对应线程问题。")])]),a("li",[a("p",[l._v("或者将线程号ID转换成16进制，使用jstack -l 线程ID（十六进制），或者使用 jstack 进程ID|grep -A 10 进程ID（十六进制）。")])])]),a("h2",[l._v("20.2、OOM排除：")]),a("ul",[a("li",[l._v("先查看进程是否存在，在查看日志，是否有对应的异常信息。")]),a("li",[l._v("获取进程ID，使用jmap -heap 进程号，查看堆内存占用情况。")]),a("li",[l._v("jmap -histo 进程号 | head -n 100 查询对象统计情况。")])]),a("h1",[l._v("21、如何设计一个系统")]),a("h2",[l._v("21.1、理解需求：")]),a("h3",[l._v("21.1.1、功能性需求：")]),a("ul",[a("li",[l._v("解决什么问题，达到什么目的，使用的场景。")]),a("li",[l._v("系统的输入和输出是什么。")]),a("li",[l._v("提供什么样的服务。")]),a("li",[l._v("系统的边界是什么。")]),a("li",[l._v("有哪些角色，有哪些模块。")])]),a("h3",[l._v("21.1.2、非功能性需求：")]),a("ul",[a("li",[l._v("可用性目标。")]),a("li",[l._v("总体用户，活跃用户，用户分布。")]),a("li",[l._v("数据存储效率，数据量级。")]),a("li",[l._v("接口响应，系统操作类型（比如：延时任务居多，需要通知服务等）。")]),a("li",[l._v("读写比例。")])]),a("h2",[l._v("21.2、系统设计：")]),a("p",[l._v("C4模型：")]),a("ul",[a("li",[l._v("上下文：涉及系统边界，梳理系统与其他系统边界。")]),a("li",[l._v("容器：梳理系统内部模块，子服务等，中间件，数据库等服务组件。")]),a("li",[l._v("组件：单个模块，子服务中的一些细节。")]),a("li",[l._v("code层面：一般指类图。")])]),a("p",[l._v("简单的来说：")]),a("ul",[a("li",[l._v("系统上下文架构。")]),a("li",[l._v("系统和服务的关系。")]),a("li",[l._v("子系统内部里面的关系。")])]),a("h2",[l._v("21.3、API：")]),a("ul",[a("li",[l._v("接口设计，身份验证，path等信息。")]),a("li",[l._v("响应体的设计，响应码的设计。")])]),a("h2",[l._v("21.4、数据模型设计：")]),a("p",[l._v("数据的设计。")]),a("h2",[l._v("21.5、高可用，高性能和可监控的设计：")]),a("ul",[a("li",[l._v("超时控制。")]),a("li",[l._v("流量监控。")]),a("li",[l._v("重试机制等。")])]),a("p",[l._v("​")]),a("p",[l._v("​")]),a("p",[l._v("​")]),a("p",[l._v("​")])])])])}],e=i("2877"),s={},r=Object(e["a"])(s,a,_,!1,null,null,null);v["default"]=r.exports},f762:function(l,v,i){l.exports=i.p+"img/1675651548660.cbc91e73.png"},fba3:function(l,v,i){l.exports=i.p+"img/1676344196064.73052146.jpg"}}]);
//# sourceMappingURL=chunk-5f1597d3.597fc8b5.js.map