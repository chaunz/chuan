{"version":3,"sources":["webpack:///./src/assets/documents/document1/JAVA内存泄漏详解.md?fed4","webpack:///./src/assets/documents/document1/JAVA内存泄漏详解.md"],"names":["render","_vm","this","_h","$createElement","_self","_c","_m","staticRenderFns","_v","pre","attrs","script","component"],"mappings":"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","file":"js/chunk-2d0dd7df.8eaec1a7.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',[_c('html',[_c('head'),_c('body',[_c('h1',[_vm._v(\"JAVA内存泄漏详解\")]),_c('h2',[_vm._v(\"内容标签\")]),_c('p',[_vm._v(\"内容难度：中等\")]),_c('p',[_vm._v(\"知识点标签：垃圾收集器（GC）、堆（Heap）、栈（Queue）\")]),_c('h2',[_vm._v(\"1. JAVA中的内存管理\")]),_c('pre',{pre:true},[_c('code',{pre:true,attrs:{\"v-pre\":\"\"}},[_vm._v(\"Java的一个重要特性就是通过垃圾收集器(GC)自动管理内存的回收，而不需要程序员自己来释放内存。理论上Java中所有不会再被利用的对象所占用的内存，都可以被GC回收，但是Java也存在内存泄露，但它的表现与C++不同。\\n\")])]),_c('p',[_vm._v(\"​ 要了解Java中的内存泄露，首先就得知道Java中的内存是如何管理的。\")]),_c('p',[_vm._v(\"​ 在Java程序中，我们通常使用new为对象分配内存，而这些内存空间都在堆（Heap）上。\")]),_c('p',[_vm._v(\"​ 下面看一个示例：\")]),_c('pre',{pre:true},[_c('code',{pre:true,attrs:{\"v-pre\":\"\"}},[_vm._v(\"class test {\\n    public static void main(String args[]){\\n        Object o1 = new Object();//obj1\\n        Object o2 = new Object();//obj2\\n        o2 = o1;\\n        //...此时，obj2是可以被清理的\\n    }\\n}\\n\")])]),_c('p',[_vm._v(\"​ Java使用有向图的方式进行内存管理：\")]),_c('p',[_c('img',{attrs:{\"src\":\"https://img.jbzj.com/file_images/article/201609/201609091035587.gif\",\"alt\":\"img\"}})]),_c('p',[_vm._v(\"​ 在有向图中，我们叫作obj1是可达的，obj2就是不可达的，显然不可达的可以被清理。\")]),_c('p',[_vm._v(\"​ 内存的释放，也即清理那些不可达的对象，是由GC决定和执行的，所以GC会监控每一个对象的状态，包括申请、引用、被引用和赋值等。\"),_c('strong',[_vm._v(\"释放对象的根本原则就是对象不会再被使用\")])]),_c('ul',[_c('li',[_vm._v(\"给对象赋予了空值null，之后再没有调用过。\")]),_c('li',[_vm._v(\"另一个是给对象赋予了新值，这样重新分配了内存空间。\")])]),_c('p',[_vm._v(\"​ 通常，会认为在堆上分配对象的代价比较大，但是GC却优化了这一操作：C++中，在堆上分配一块内存，会查找一块适用的内存加以分配，如果对象销毁，这块内存就可以重用；而Java中，就想一条长的带子，每分配一个新的对象，Java的“堆指针”就向后移动到尚未分配的区域。所以，Java分配内存的效率，可与C++媲美。\")]),_c('p',[_vm._v(\"​ 但是这种工作方式有一个问题：\"),_c('strong',[_vm._v(\"如果频繁的申请内存，资源将会耗尽\")]),_vm._v(\"。这时GC就介入了进来，它会回收空间，并使堆中的对象排列更紧凑。这样，就始终会有足够大的内存空间可以分配。\")]),_c('p',[_vm._v(\"GC清理时的引用计数方式：当引用连接至新对象时，引用计数+1；当某个引用离开作用域或被设置为null时，引用计数-1，GC发现这个计数为0时，就回收其占用的内存。这个开销会在引用程序的整个生命周期发生，并且不能处理循环引用的情况。所以这种方式只是用来说明GC的工作方式，而不会被任何一种Java虚拟机应用。\")]),_c('h2',[_vm._v(\"2. JAVA 中的内存泄露\")]),_c('p',[_vm._v(\"​ Java中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露。\")]),_c('p',[_vm._v(\"​ Java中的内存泄露与C++中的表现有所不同。\")]),_c('p',[_vm._v(\"​ 在C++中，所有被分配了内存的对象，不再使用后，都必须程序员手动的释放他们。所以，每个类，都会含有一个析构函数，作用就是完成清理工作，如果我们忘记了某些对象的释放，就会造成内存泄露。\")]),_c('p',[_vm._v(\"​ 但是在Java中，我们不用（也没办法）自己释放内存，无用的对象由GC自动清理，这也极大的简化了我们的编程工作。但，实际有时候一些不再会被使用的对象，在GC看来不能被释放，就会造成内存泄露。\")]),_c('p',[_vm._v(\"​ 我们知道，对象都是有生命周期的，有的长，有的短，\"),_c('strong',[_vm._v(\"如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露\")]),_vm._v(\"。我们举一个简单的例子：\")]),_c('pre',{pre:true},[_c('code',{pre:true,attrs:{\"v-pre\":\"\"}},[_vm._v(\"public class Simple {\\n    Object object;\\n    \\n    public void method1(){\\n        object = new Object();\\n   \\t\\t//...其他代码\\n    }\\n}\\n\")])]),_c('p',[_vm._v(\"​ 这里的object实例，其实我们期望它只作用于method1()方法中，且其他地方不会再用到它，但是，当method1()方法执行完成后，object对象所分配的内存不会马上被认为是可以被释放的对象，只有在Simple类创建的对象被释放后才会被释放，严格的说，这就是一种内存泄露。解决方法就是将object作为method1()方法中的局部变量。当然，如果一定要这么写，可以改为这样：\")]),_c('pre',{pre:true},[_c('code',{pre:true,attrs:{\"v-pre\":\"\"}},[_vm._v(\"public class Simple {\\n \\n    Object object;\\n \\n    public void method1(){\\n        object = new Object();\\n        //...其他代码\\n        object = null;\\n    }\\n}\\n\")])]),_c('p',[_vm._v(\"这样，之前“new Object()”分配的内存，就可以被GC回收。\")]),_c('p',[_vm._v(\"到这里，Java的内存泄露应该都比较清楚了。下面再进一步说明：\")]),_c('ul',[_c('li',[_vm._v(\"在堆中的分配的内存，在没有将其释放掉的时候，就将所有能访问这块内存的方式都删掉（如指针重新赋值），这是针对c++等语言的，Java中的GC会帮我们处理这种情况，所以我们无需关心。\")]),_c('li',[_vm._v(\"在内存对象明明已经不需要的时候，还仍然保留着这块内存和它的访问方式（引用），这是所有语言都有可能会出现的内存泄漏方式。编程时如果不小心，我们很容易发生这种情况，如果不太严重，可能就只是短暂的内存泄露。\")])]),_c('h2',[_vm._v(\"3. 一些容易发生内存泄露的例子和解决方法\")]),_c('p',[_vm._v(\"​ 像上面例子中的情况很容易发生，也是我们最容易忽略并引发内存泄露的情况，解决的原则就是尽量减小对象的作用域（比如android studio中，上面的代码就会发出警告，并给出的建议是将类的成员变量改写为方法内的局部变量）以及手动设置null值。\")]),_c('pre',{pre:true},[_c('code',{pre:true,attrs:{\"v-pre\":\"\"}},[_vm._v(\"至于作用域，需要在我们编写代码时多注意；null值的手动设置，我们可以看一下Java容器LinkedList源码中删除指定节点的内部方法：\\n\")])]),_c('pre',{pre:true},[_c('code',{pre:true,attrs:{\"v-pre\":\"\"}},[_vm._v(\"//删除指定节点并返回被删除的元素值\\nE unlink(Node<E> x) {\\n    //获取当前值和前后节点\\n    final E element = x.item;\\n    final Node<E> next = x.next;\\n    final Node<E> prev = x.prev;\\n    if (prev == null) {\\n        first = next; //如果前一个节点为空(如当前节点为首节点)，后一个节点成为新的首节点\\n    } else {\\n        prev.next = next;//如果前一个节点不为空，那么他先后指向当前的下一个节点\\n        x.prev = null;\\n    }\\n    if (next == null) {\\n        last = prev; //如果后一个节点为空(如当前节点为尾节点)，当前节点前一个成为新的尾节点\\n    } else {\\n        next.prev = prev;//如果后一个节点不为空，后一个节点向前指向当前的前一个节点\\n        x.next = null;\\n    }\\n    x.item = null;\\n    size--;\\n    modCount++;\\n    return element;\\n}\\n\")])]),_c('pre',{pre:true},[_c('code',{pre:true,attrs:{\"v-pre\":\"\"}},[_vm._v(\"除了修改节点间的关联关系，我们还要做的就是赋值为null的操作，不管GC何时会开始清理，我们都应及时的将无用的对象标记为可被清理的对象。\\n\\n我们知道Java容器ArrayList是数组实现的，如果我们要为其写一个pop()（弹出）方法，可能会是这样：\\n\")])]),_c('pre',{pre:true},[_c('code',{pre:true,attrs:{\"v-pre\":\"\"}},[_vm._v(\"public E pop(){\\n    if(size == 0)\\n        return null;\\n    else\\n        return (E) elementData[--size];\\n}\\n\")])]),_c('p',[_vm._v(\"写法很简洁，但这里却会造成内存溢出：elementData[size-1]依然持有E类型对象的引用，并且暂时不能被GC回收。我们可以如下修改：\")]),_c('pre',{pre:true},[_c('code',{pre:true,attrs:{\"v-pre\":\"\"}},[_vm._v(\"public E pop(){\\n    if(size == 0)\\n        return null;\\n    else{\\n        E e = (E) elementData[--size];\\n        elementData[size] = null;\\n        return e;\\n    }\\n}\\n\")])]),_c('p',[_vm._v(\"我们写代码并不能一味的追求简洁，首要是保证其正确性。\")]),_c('h2',[_vm._v(\"4. 各种提供了close()方法的对象\")]),_c('p',[_vm._v(\"​ 比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，以及使用其他框架的时候，除非其显式的调用了其close()方法（或类似方法）将其连接关闭，否则是不会自动被GC回收的。其实原因依然是长生命周期对象持有短生命周期对象的引用。\")]),_c('p',[_vm._v(\"​ 很多人使用过持久层框架（如：mybatis、hibernate），我们操作数据库时，通过SessionFactory获取一个session：\")]),_c('pre',{pre:true},[_c('code',{pre:true,attrs:{\"v-pre\":\"\"}},[_vm._v(\"Session session=sessionFactory.openSession();\\n\")])]),_c('p',[_vm._v(\"​ 完成后我们必须调用close()方法关闭：\")]),_c('pre',{pre:true},[_c('code',{pre:true,attrs:{\"v-pre\":\"\"}},[_vm._v(\"session.close();\\n\")])]),_c('p',[_vm._v(\"SessionFactory就是一个长生命周期的对象，而session相对是个短生命周期的对象，但是框架这么设计是合理的：它并不清楚我们要使用session到多久，于是只能提供一个方法让我们自己决定何时不再使用。\")]),_c('p',[_vm._v(\"因为在close()方法调用之前，可能会抛出异常而导致方法不能被调用，我们通常使用try语言，然后再finally语句中执行close()等清理工作：\")]),_c('pre',{pre:true},[_c('code',{pre:true,attrs:{\"v-pre\":\"\"}},[_vm._v(\"try{\\n    session=sessionFactory.openSession();\\n    //...其他操作\\n}finally{\\n    session.close();\\n}\\n\")])]),_c('h2',[_vm._v(\"5. 与清理相关的方法\")]),_c('p',[_vm._v(\"主要谈论gc()和finalize()方法。\")]),_c('h3',[_vm._v(\"gc()\")]),_c('p',[_vm._v(\"​ 对于程序员来说，GC基本是透明的，不可见的。运行GC的函数是System.gc()，调用后启动垃圾回收器开始清理。\")]),_c('p',[_vm._v(\"​ 但是根据Java语言规范定义， 该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。\")]),_c('pre',{pre:true},[_c('code',{pre:true,attrs:{\"v-pre\":\"\"}},[_vm._v(\"JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。\\n\")])]),_c('h3',[_vm._v(\"finalize()\")]),_c('p',[_vm._v(\"​ finalize()是Object类中的方法。\")]),_c('p',[_vm._v(\"​ Java编程思想中是这么解释的：一旦GC准备好释放对象所占用的的存储空间，将先调用其finalize()方法，并在下一次GC回收动作发生时，才会真正回收对象占用的内存，所以一些清理工作，我们可以放到finalize()中。\")]),_c('p',[_vm._v(\"​ 该方法的一个重要的用途是：当在java中调用非java代码（如c和c++）时，在这些非java代码中可能会用到相应的申请内存的操作（如c的malloc()函数），而在这些非java代码中并没有有效的释放这些内存，就可以用finalize()方法，并在里面调用本地方法的free()等函数。\")]),_c('p',[_vm._v(\"​ 所以finalize()并不适合用作普通的清理工作。\")]),_c('hr'),_c('p',[_vm._v(\"​ 总的来说，内存泄露问题，还是编码不认真导致的，Wirte Code！！！\")])])])])}]\n\nexport { render, staticRenderFns }","import { render, staticRenderFns } from \"./JAVA内存泄漏详解.md?vue&type=template&id=5eb7d26a&\"\nvar script = {}\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}